var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/test-utils.ts
__export(exports, {
  printBlueprints: () => printBlueprints,
  printState: () => printState
});

// appFiles/src/lib/formify/index.ts
var G = __toModule(require("graphql"));
var formify = async ({
  schema,
  optimizedDocumentNode
}) => {
  const blueprints = [];
  const visitor = {
    OperationDefinition: (node2) => {
      if (!node2.name) {
        return __spreadProps(__spreadValues({}, node2), {
          name: {
            kind: "Name",
            value: `QueryOperation`
          }
        });
      }
      return node2;
    }
  };
  const documentNodeWithName = G.visit(optimizedDocumentNode, visitor);
  const optimizedQuery = documentNodeWithName;
  const typeInfo = new G.TypeInfo(schema);
  const addMetaFields = (node2) => {
    var _a;
    return __spreadProps(__spreadValues({}, node2), {
      selectionSet: __spreadProps(__spreadValues({}, node2.selectionSet || {
        kind: "SelectionSet",
        selections: []
      }), {
        selections: [...((_a = node2.selectionSet) == null ? void 0 : _a.selections) || [], ...metaFields]
      })
    });
  };
  const getPath = (path, node2) => {
    let currentLevel = node2;
    const fieldPath = [];
    path.forEach((item) => {
      currentLevel = currentLevel[item];
      if (!Array.isArray(currentLevel)) {
        if (currentLevel.kind === "Field") {
          fieldPath.push(currentLevel.name.value);
        }
      }
    });
    return fieldPath;
  };
  const addBlueprints = (node2, _key, _parent, path, ancestors) => {
    const fieldPath = getPath(path, ancestors[0]);
    const nextInfo = (innerNode) => {
      var _a, _b;
      const fields2 = [];
      G.visit(innerNode, G.visitWithTypeInfo(typeInfo, {
        Field: {
          enter: (node3) => {
            var _a2, _b2, _c;
            typeInfo.enter(node3);
            if (node3.name.value !== innerNode.name.value) {
              if ((_a2 = node3.selectionSet) == null ? void 0 : _a2.selections.length) {
                const subInfo = nextInfo(node3);
                fields2.push({
                  name: node3.name.value,
                  alias: ((_b2 = node3.alias) == null ? void 0 : _b2.value) || node3.name.value,
                  fields: subInfo.fields
                });
                return false;
              } else {
                fields2.push({
                  name: node3.name.value,
                  alias: ((_c = node3.alias) == null ? void 0 : _c.value) || node3.name.value
                });
              }
            }
          },
          leave: (node3) => {
            typeInfo.leave(node3);
          }
        }
      }));
      if (fields2 == null ? void 0 : fields2.length) {
        return {
          name: innerNode.name.value,
          alias: ((_a = innerNode.alias) == null ? void 0 : _a.value) || innerNode.name.value,
          fields: fields2
        };
      } else {
        return {
          name: innerNode.name.value,
          alias: ((_b = innerNode.alias) == null ? void 0 : _b.value) || innerNode.name.value
        };
      }
    };
    const result = nextInfo(node2);
    const mergeFields = (fields2) => {
      if (!fields2) {
        return [];
      }
      const groupBy = (items, key) => items.reduce((result2, item) => __spreadProps(__spreadValues({}, result2), {
        [item[key]]: [...result2[item[key]] || [], item]
      }), {});
      const groups = groupBy(fields2, "alias");
      const groupedFields = [];
      Object.entries(groups).forEach(([name, items]) => {
        const subFields = [];
        items.forEach((item) => {
          var _a;
          (_a = item.fields) == null ? void 0 : _a.forEach((field) => subFields.push(field));
        });
        const fieldName = items[0].name;
        const fieldAlias = items[0].alias;
        if (subFields == null ? void 0 : subFields.length) {
          groupedFields.push({
            name: fieldName,
            alias: fieldAlias,
            fields: subFields
          });
        } else {
          groupedFields.push({ name: fieldName, alias: fieldAlias });
        }
      });
      return groupedFields;
    };
    const fields = mergeFields(result.fields);
    if (false) {
    } else {
      if (fields == null ? void 0 : fields.length) {
        blueprints.push({
          name: result.name,
          alias: result.alias,
          fields,
          path: fieldPath
        });
      } else {
        blueprints.push({
          name: result.name,
          alias: result.alias,
          path: fieldPath
        });
      }
    }
  };
  const formifyVisitor = {
    InlineFragment: {
      enter: (node2) => {
        typeInfo.enter(node2);
      },
      leave: (node2) => {
        typeInfo.leave(node2);
      }
    },
    Field: {
      enter: (node2, key, parent, path, ancestors) => {
        typeInfo.enter(node2);
        const type = typeInfo.getType();
        if (type) {
          const namedType = G.getNamedType(type);
          if (G.isInterfaceType(namedType)) {
            if (namedType.name === "Node") {
              return addMetaFields(node2, key, parent, path, ancestors);
            }
          }
          if (G.isUnionType(namedType)) {
            const types = namedType.getTypes();
            if (types.every((type2) => {
              return type2.getInterfaces().some((intfc) => intfc.name === "Node");
            })) {
              return addMetaFields(node2, key, parent, path, ancestors);
            }
          }
          if (G.isObjectType(namedType)) {
            if (namedType.getInterfaces().some((intfc) => intfc.name === "Node")) {
              return addMetaFields(node2, key, parent, path, ancestors);
            }
          }
        }
      }
    }
  };
  const blueprintVisitor = {
    InlineFragment: {
      enter: (node2) => {
        typeInfo.enter(node2);
      },
      leave: (node2) => {
        typeInfo.leave(node2);
      }
    },
    Field: {
      enter: (node2, key, parent, path, ancestors) => {
        typeInfo.enter(node2);
        const type = typeInfo.getType();
        if (type) {
          const namedType = G.getNamedType(type);
          if (G.isInterfaceType(namedType)) {
            if (namedType.name === "Node") {
              addBlueprints(node2, key, parent, path, ancestors);
              return false;
            }
          }
          if (G.isUnionType(namedType)) {
            const types = namedType.getTypes();
            if (types.every((type2) => {
              return type2.getInterfaces().some((intfc) => intfc.name === "Node");
            })) {
              addBlueprints(node2, key, parent, path, ancestors);
              return false;
            }
          }
          if (G.isObjectType(namedType)) {
            if (namedType.getInterfaces().some((intfc) => intfc.name === "Node")) {
              addBlueprints(node2, key, parent, path, ancestors);
              return false;
            }
          }
        }
      }
    }
  };
  const formifiedQuery = G.visit(optimizedQuery, G.visitWithTypeInfo(typeInfo, formifyVisitor));
  G.visit(formifiedQuery, G.visitWithTypeInfo(typeInfo, blueprintVisitor));
  return { formifiedQuery, blueprints };
};
var node = G.parse(`
 query Sample {
  ...on Document {
    _internalValues: _values
    _internalSys: _sys {
      breadcrumbs
      basename
      filename
      path
      extension
      relativePath
      title
      template
      collection {
        name
        slug
        label
        path
        format
        matches
        templates
        fields
        __typename
      }
      __typename
    }
  }
 }`);
var metaFields = node.definitions[0].selectionSet.selections;

// src/test-utils.ts
var printState = (obj) => {
  return obj;
};
var printBlueprints = ({ schema, client, query }) => {
  const optimizedQuery = client.getOptimizedQuery(query);
  const res = formify({ schema, optimizedQuery });
  const { formifiedQuery, blueprints } = res;
  return { formifiedQuery, blueprints };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  printBlueprints,
  printState
});
