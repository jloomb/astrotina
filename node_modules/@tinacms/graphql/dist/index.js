var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/index.ts
__export(exports, {
  TinaFetchError: () => TinaFetchError,
  TinaGraphQLError: () => TinaGraphQLError,
  TinaParseDocumentError: () => TinaParseDocumentError,
  TinaQueryError: () => TinaQueryError,
  assertShape: () => assertShape,
  buildDotTinaFiles: () => buildDotTinaFiles,
  buildSchema: () => buildSchema,
  createDatabase: () => createDatabase,
  createSchema: () => createSchema,
  getASTSchema: () => getASTSchema,
  handleFetchErrorError: () => handleFetchErrorError,
  parseFile: () => parseFile,
  resolve: () => resolve,
  sequential: () => sequential,
  stringifyFile: () => stringifyFile
});
var import_fs_extra2 = __toModule(require("fs-extra"));
var import_path4 = __toModule(require("path"));
var import_graphql6 = __toModule(require("graphql"));

// src/build.ts
var import_lodash3 = __toModule(require("lodash"));
var import_fs_extra = __toModule(require("fs-extra"));
var import_graphql2 = __toModule(require("graphql"));

// src/ast-builder/index.ts
var import_lodash = __toModule(require("lodash"));

// src/util.ts
var yup = __toModule(require("yup"));
var import_graphql = __toModule(require("graphql"));
var sequential = async (items, callback) => {
  const accum = [];
  if (!items) {
    return [];
  }
  const reducePromises = async (previous, endpoint) => {
    const prev = await previous;
    if (prev) {
      accum.push(prev);
    }
    return callback(endpoint, accum.length);
  };
  const result = await items.reduce(reducePromises, Promise.resolve());
  if (result) {
    accum.push(result);
  }
  return accum;
};
function assertShape(value, yupSchema, errorMessage) {
  const shape = yupSchema(yup);
  try {
    shape.validateSync(value);
  } catch (e) {
    const message = errorMessage || `Failed to assertShape - ${e.message}`;
    throw new import_graphql.GraphQLError(message, null, null, null, null, null, {
      stack: e.stack
    });
  }
}
var lastItem = (arr) => {
  return arr[arr.length - 1];
};

// src/ast-builder/index.ts
var SysFieldDefinition = {
  kind: "Field",
  name: {
    kind: "Name",
    value: "_sys"
  },
  arguments: [],
  directives: [],
  selectionSet: {
    kind: "SelectionSet",
    selections: [
      {
        kind: "Field",
        name: {
          kind: "Name",
          value: "filename"
        },
        arguments: [],
        directives: []
      },
      {
        kind: "Field",
        name: {
          kind: "Name",
          value: "basename"
        },
        arguments: [],
        directives: []
      },
      {
        kind: "Field",
        name: {
          kind: "Name",
          value: "breadcrumbs"
        },
        arguments: [],
        directives: []
      },
      {
        kind: "Field",
        name: {
          kind: "Name",
          value: "path"
        },
        arguments: [],
        directives: []
      },
      {
        kind: "Field",
        name: {
          kind: "Name",
          value: "relativePath"
        },
        arguments: [],
        directives: []
      },
      {
        kind: "Field",
        name: {
          kind: "Name",
          value: "extension"
        },
        arguments: [],
        directives: []
      }
    ]
  }
};
var astBuilder = {
  FormFieldBuilder: ({
    name: name2,
    additionalFields
  }) => {
    return astBuilder.ObjectTypeDefinition({
      name: name2,
      interfaces: [astBuilder.NamedType({ name: "FormField" })],
      fields: [
        astBuilder.FieldDefinition({
          name: "name",
          required: true,
          type: astBuilder.TYPES.String
        }),
        astBuilder.FieldDefinition({
          name: "label",
          required: true,
          type: astBuilder.TYPES.String
        }),
        astBuilder.FieldDefinition({
          name: "component",
          required: true,
          type: astBuilder.TYPES.String
        }),
        ...additionalFields || []
      ]
    });
  },
  ScalarTypeDefinition: ({
    name: name2,
    description
  }) => {
    return {
      kind: "ScalarTypeDefinition",
      name: {
        kind: "Name",
        value: name2
      },
      description: {
        kind: "StringValue",
        value: description || ""
      },
      directives: []
    };
  },
  InputValueDefinition: ({
    name: name2,
    type,
    list,
    required
  }) => {
    let res = {};
    const namedType = {
      kind: "NamedType",
      name: {
        kind: "Name",
        value: type
      }
    };
    const def = {
      kind: "InputValueDefinition",
      name: {
        kind: "Name",
        value: name2
      }
    };
    if (list) {
      if (required) {
        res = __spreadProps(__spreadValues({}, def), {
          type: {
            kind: "ListType",
            type: {
              kind: "NonNullType",
              type: namedType
            }
          }
        });
      } else {
        res = __spreadProps(__spreadValues({}, def), {
          type: {
            kind: "ListType",
            type: namedType
          }
        });
      }
    } else {
      if (required) {
        res = __spreadProps(__spreadValues({}, def), {
          type: {
            kind: "NonNullType",
            type: namedType
          }
        });
      } else {
        res = __spreadProps(__spreadValues({}, def), {
          type: namedType
        });
      }
    }
    return res;
  },
  EnumDefinition: (props) => {
    return {
      kind: "EnumTypeDefinition",
      name: {
        kind: "Name",
        value: props.name
      },
      values: props.values.map((val) => {
        return {
          kind: "EnumValueDefinition",
          name: {
            kind: "Name",
            value: val
          }
        };
      })
    };
  },
  FieldNodeDefinition: ({
    name: name2,
    type,
    args = [],
    list,
    required
  }) => ({
    name: { kind: "Name", value: name2 },
    kind: "Field"
  }),
  FieldDefinition: ({
    name: name2,
    type,
    args = [],
    list,
    required
  }) => {
    let res = {};
    const namedType = {
      kind: "NamedType",
      name: {
        kind: "Name",
        value: type
      }
    };
    const def = {
      kind: "FieldDefinition",
      name: {
        kind: "Name",
        value: name2
      },
      arguments: args
    };
    if (list) {
      if (required) {
        res = __spreadProps(__spreadValues({}, def), {
          type: {
            kind: "NonNullType",
            type: {
              kind: "ListType",
              type: {
                kind: "NonNullType",
                type: namedType
              }
            }
          }
        });
      } else {
        res = __spreadProps(__spreadValues({}, def), {
          type: {
            kind: "ListType",
            type: namedType
          }
        });
      }
    } else {
      if (required) {
        res = __spreadProps(__spreadValues({}, def), {
          type: {
            kind: "NonNullType",
            type: namedType
          }
        });
      } else {
        res = __spreadProps(__spreadValues({}, def), {
          type: namedType
        });
      }
    }
    return res;
  },
  InterfaceTypeDefinition: ({
    name: name2,
    fields,
    description = ""
  }) => {
    return {
      kind: "InterfaceTypeDefinition",
      description: { kind: "StringValue", value: description },
      name: {
        kind: "Name",
        value: name2
      },
      interfaces: [],
      directives: [],
      fields
    };
  },
  InputObjectTypeDefinition: ({
    name: name2,
    fields
  }) => ({
    kind: "InputObjectTypeDefinition",
    name: {
      kind: "Name",
      value: name2
    },
    fields
  }),
  UnionTypeDefinition: ({
    name: name2,
    types
  }) => ({
    kind: "UnionTypeDefinition",
    name: {
      kind: "Name",
      value: name2
    },
    directives: [],
    types: types.map((name3) => ({
      kind: "NamedType",
      name: {
        kind: "Name",
        value: name3
      }
    }))
  }),
  NamedType: ({ name: name2 }) => {
    return {
      kind: "NamedType",
      name: {
        kind: "Name",
        value: name2
      }
    };
  },
  ObjectTypeDefinition: ({
    name: name2,
    fields,
    interfaces = [],
    directives = [],
    args = []
  }) => ({
    kind: "ObjectTypeDefinition",
    interfaces,
    directives,
    name: {
      kind: "Name",
      value: name2
    },
    fields
  }),
  FieldWithSelectionSetDefinition: ({
    name: name2,
    selections
  }) => {
    return {
      name: { kind: "Name", value: name2 },
      kind: "Field",
      selectionSet: {
        kind: "SelectionSet",
        selections
      }
    };
  },
  InlineFragmentDefinition: ({
    name: name2,
    selections
  }) => {
    return {
      kind: "InlineFragment",
      selectionSet: {
        kind: "SelectionSet",
        selections
      },
      typeCondition: {
        kind: "NamedType",
        name: {
          kind: "Name",
          value: name2
        }
      }
    };
  },
  FragmentDefinition: ({
    name: name2,
    fragmentName,
    selections
  }) => {
    return {
      kind: "FragmentDefinition",
      name: {
        kind: "Name",
        value: fragmentName
      },
      typeCondition: {
        kind: "NamedType",
        name: {
          kind: "Name",
          value: name2
        }
      },
      directives: [],
      selectionSet: {
        kind: "SelectionSet",
        selections
      }
    };
  },
  TYPES: {
    Scalar: (type) => {
      const scalars = {
        string: "String",
        boolean: "Boolean",
        number: "Float",
        datetime: "String",
        image: "String",
        text: "String"
      };
      return scalars[type];
    },
    MultiCollectionDocument: "DocumentNode",
    CollectionDocumentUnion: "DocumentUnion",
    String: "String",
    Reference: "Reference",
    Collection: "Collection",
    ID: "ID",
    SystemInfo: "SystemInfo",
    Boolean: "Boolean",
    JSON: "JSON",
    Node: "Node",
    PageInfo: "PageInfo",
    Connection: "Connection",
    Number: "Float",
    Document: "Document"
  },
  QueryOperationDefinition: ({
    queryName,
    fragName
  }) => {
    return {
      kind: "OperationDefinition",
      operation: "query",
      name: {
        kind: "Name",
        value: queryName
      },
      variableDefinitions: [
        {
          kind: "VariableDefinition",
          type: {
            kind: "NonNullType",
            type: {
              kind: "NamedType",
              name: { kind: "Name", value: "String" }
            }
          },
          variable: {
            kind: "Variable",
            name: { kind: "Name", value: "relativePath" }
          }
        }
      ],
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "Field",
            name: {
              kind: "Name",
              value: queryName
            },
            arguments: [
              {
                kind: "Argument",
                name: {
                  kind: "Name",
                  value: "relativePath"
                },
                value: {
                  kind: "Variable",
                  name: {
                    kind: "Name",
                    value: "relativePath"
                  }
                }
              }
            ],
            directives: [],
            selectionSet: {
              kind: "SelectionSet",
              selections: [
                {
                  kind: "InlineFragment",
                  typeCondition: {
                    kind: "NamedType",
                    name: {
                      kind: "Name",
                      value: "Document"
                    }
                  },
                  directives: [],
                  selectionSet: {
                    kind: "SelectionSet",
                    selections: [
                      SysFieldDefinition,
                      {
                        kind: "Field",
                        name: {
                          kind: "Name",
                          value: "id"
                        },
                        arguments: [],
                        directives: []
                      }
                    ]
                  }
                },
                {
                  kind: "FragmentSpread",
                  name: {
                    kind: "Name",
                    value: fragName
                  },
                  directives: []
                }
              ]
            }
          }
        ]
      }
    };
  },
  ListQueryOperationDefinition: ({
    queryName,
    fragName,
    filterType,
    dataLayer
  }) => {
    const variableDefinitions = [
      {
        kind: "VariableDefinition",
        variable: {
          kind: "Variable",
          name: {
            kind: "Name",
            value: "before"
          }
        },
        type: {
          kind: "NamedType",
          name: {
            kind: "Name",
            value: "String"
          }
        },
        directives: []
      },
      {
        kind: "VariableDefinition",
        variable: {
          kind: "Variable",
          name: {
            kind: "Name",
            value: "after"
          }
        },
        type: {
          kind: "NamedType",
          name: {
            kind: "Name",
            value: "String"
          }
        },
        directives: []
      },
      {
        kind: "VariableDefinition",
        variable: {
          kind: "Variable",
          name: {
            kind: "Name",
            value: "first"
          }
        },
        type: {
          kind: "NamedType",
          name: {
            kind: "Name",
            value: "Float"
          }
        },
        directives: []
      },
      {
        kind: "VariableDefinition",
        variable: {
          kind: "Variable",
          name: {
            kind: "Name",
            value: "last"
          }
        },
        type: {
          kind: "NamedType",
          name: {
            kind: "Name",
            value: "Float"
          }
        },
        directives: []
      },
      {
        kind: "VariableDefinition",
        variable: {
          kind: "Variable",
          name: {
            kind: "Name",
            value: "sort"
          }
        },
        type: {
          kind: "NamedType",
          name: {
            kind: "Name",
            value: "String"
          }
        },
        directives: []
      }
    ];
    const queryArguments = [
      {
        kind: "Argument",
        name: {
          kind: "Name",
          value: "before"
        },
        value: {
          kind: "Variable",
          name: {
            kind: "Name",
            value: "before"
          }
        }
      },
      {
        kind: "Argument",
        name: {
          kind: "Name",
          value: "after"
        },
        value: {
          kind: "Variable",
          name: {
            kind: "Name",
            value: "after"
          }
        }
      },
      {
        kind: "Argument",
        name: {
          kind: "Name",
          value: "first"
        },
        value: {
          kind: "Variable",
          name: {
            kind: "Name",
            value: "first"
          }
        }
      },
      {
        kind: "Argument",
        name: {
          kind: "Name",
          value: "last"
        },
        value: {
          kind: "Variable",
          name: {
            kind: "Name",
            value: "last"
          }
        }
      },
      {
        kind: "Argument",
        name: {
          kind: "Name",
          value: "sort"
        },
        value: {
          kind: "Variable",
          name: {
            kind: "Name",
            value: "sort"
          }
        }
      }
    ];
    if (dataLayer) {
      queryArguments.push({
        kind: "Argument",
        name: {
          kind: "Name",
          value: "filter"
        },
        value: {
          kind: "Variable",
          name: {
            kind: "Name",
            value: "filter"
          }
        }
      });
      variableDefinitions.push({
        kind: "VariableDefinition",
        variable: {
          kind: "Variable",
          name: {
            kind: "Name",
            value: "filter"
          }
        },
        type: {
          kind: "NamedType",
          name: {
            kind: "Name",
            value: filterType
          }
        },
        directives: []
      });
    }
    return {
      kind: "OperationDefinition",
      operation: "query",
      name: {
        kind: "Name",
        value: queryName
      },
      variableDefinitions,
      directives: [],
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "Field",
            name: {
              kind: "Name",
              value: queryName
            },
            arguments: queryArguments,
            directives: [],
            selectionSet: {
              kind: "SelectionSet",
              selections: [
                {
                  kind: "Field",
                  name: {
                    kind: "Name",
                    value: "pageInfo"
                  },
                  arguments: [],
                  directives: [],
                  selectionSet: {
                    kind: "SelectionSet",
                    selections: [
                      {
                        kind: "Field",
                        name: {
                          kind: "Name",
                          value: "hasPreviousPage"
                        },
                        arguments: [],
                        directives: []
                      },
                      {
                        kind: "Field",
                        name: {
                          kind: "Name",
                          value: "hasNextPage"
                        },
                        arguments: [],
                        directives: []
                      },
                      {
                        kind: "Field",
                        name: {
                          kind: "Name",
                          value: "startCursor"
                        },
                        arguments: [],
                        directives: []
                      },
                      {
                        kind: "Field",
                        name: {
                          kind: "Name",
                          value: "endCursor"
                        },
                        arguments: [],
                        directives: []
                      }
                    ]
                  }
                },
                {
                  kind: "Field",
                  name: {
                    kind: "Name",
                    value: "totalCount"
                  },
                  arguments: [],
                  directives: []
                },
                {
                  kind: "Field",
                  name: {
                    kind: "Name",
                    value: "edges"
                  },
                  arguments: [],
                  directives: [],
                  selectionSet: {
                    kind: "SelectionSet",
                    selections: [
                      {
                        kind: "Field",
                        name: {
                          kind: "Name",
                          value: "cursor"
                        },
                        arguments: [],
                        directives: []
                      },
                      {
                        kind: "Field",
                        name: {
                          kind: "Name",
                          value: "node"
                        },
                        arguments: [],
                        directives: [],
                        selectionSet: {
                          kind: "SelectionSet",
                          selections: [
                            {
                              kind: "InlineFragment",
                              typeCondition: {
                                kind: "NamedType",
                                name: {
                                  kind: "Name",
                                  value: "Document"
                                }
                              },
                              directives: [],
                              selectionSet: {
                                kind: "SelectionSet",
                                selections: [
                                  SysFieldDefinition,
                                  {
                                    kind: "Field",
                                    name: {
                                      kind: "Name",
                                      value: "id"
                                    },
                                    arguments: [],
                                    directives: []
                                  }
                                ]
                              }
                            },
                            {
                              kind: "FragmentSpread",
                              name: {
                                kind: "Name",
                                value: fragName
                              },
                              directives: []
                            }
                          ]
                        }
                      }
                    ]
                  }
                }
              ]
            }
          }
        ]
      }
    };
  },
  toGraphQLAst: (ast) => {
    const definitions = import_lodash.default.uniqBy([
      ...extractInlineTypes(ast.query),
      ...extractInlineTypes(ast.globalTemplates),
      ...ast.definitions
    ], (field) => field.name.value);
    return {
      kind: "Document",
      definitions
    };
  }
};
var capitalize = (s) => {
  if (typeof s !== "string")
    return "";
  return s.charAt(0).toUpperCase() + s.slice(1);
};
var extractInlineTypes = (item) => {
  if (Array.isArray(item)) {
    const accumulator = item.map((i) => {
      return extractInlineTypes(i);
    });
    return import_lodash.default.flattenDeep(accumulator);
  } else {
    const accumulator = [item];
    for (const node of walk(item)) {
      if (node.kind === "UnionTypeDefinition") {
        node.types = import_lodash.default.uniqBy(node.types, (type) => type.name.value);
      }
      if (node.kind === "NamedType") {
        if (typeof node.name.value !== "string") {
          accumulator.push(node.name.value);
          node.name.value = node.name.value.name.value;
        }
      }
    }
    return accumulator;
  }
};
function* walk(maybeNode, visited = new WeakSet()) {
  if (typeof maybeNode === "string") {
    return;
  }
  if (visited.has(maybeNode)) {
    return;
  }
  for (const value of Object.values(maybeNode)) {
    if (Array.isArray(value)) {
      for (const element of value) {
        yield* walk(element, visited);
      }
    } else {
      yield* walk(value, visited);
    }
  }
  yield maybeNode;
  visited.add(maybeNode);
}
function addNamespaceToSchema(maybeNode, namespace = []) {
  if (typeof maybeNode === "string") {
    return maybeNode;
  }
  if (typeof maybeNode === "boolean") {
    return maybeNode;
  }
  const newNode = maybeNode;
  const keys = Object.keys(maybeNode);
  Object.values(maybeNode).map((m, index) => {
    const key = keys[index];
    if (Array.isArray(m)) {
      newNode[key] = m.map((element) => {
        if (!element) {
          return;
        }
        if (!element.hasOwnProperty("name")) {
          return element;
        }
        const value = element.name || element.value;
        return addNamespaceToSchema(element, [...namespace, value]);
      });
    } else {
      if (!m) {
        return;
      }
      if (!m.hasOwnProperty("name")) {
        newNode[key] = m;
      } else {
        newNode[key] = addNamespaceToSchema(m, [...namespace, m.name]);
      }
    }
  });
  return __spreadProps(__spreadValues({}, newNode), { namespace });
}
var generateNamespacedFieldName = (names, suffix = "") => {
  return (suffix ? [...names, suffix] : names).map(capitalize).join("");
};
var NAMER = {
  dataFilterTypeNameOn: (namespace) => {
    return generateNamespacedFieldName(namespace, "_FilterOn");
  },
  dataFilterTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Filter");
  },
  dataMutationTypeNameOn: (namespace) => {
    return generateNamespacedFieldName(namespace, "_MutationOn");
  },
  dataMutationTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Mutation");
  },
  dataMutationUpdateTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "UpdateMutation");
  },
  updateName: (namespace) => {
    return `update${generateNamespacedFieldName(namespace)}`;
  },
  createName: (namespace) => {
    return `create${generateNamespacedFieldName(namespace)}`;
  },
  documentQueryName: () => {
    return "document";
  },
  documentConnectionQueryName: () => {
    return "documentConnection";
  },
  collectionQueryName: () => {
    return "collection";
  },
  collectionListQueryName: () => {
    return "collections";
  },
  queryName: (namespace) => {
    return String(lastItem(namespace));
  },
  generateQueryListName: (namespace) => {
    return `${lastItem(namespace)}Connection`;
  },
  fragmentName: (namespace) => {
    return generateNamespacedFieldName(namespace, "") + "Parts";
  },
  collectionTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Collection");
  },
  documentTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace);
  },
  dataTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "");
  },
  referenceConnectionType: (namespace) => {
    return generateNamespacedFieldName(namespace, "Connection");
  },
  referenceConnectionEdgesTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "ConnectionEdges");
  }
};

// src/builder/static-definitions.ts
var interfaceDefinitions = [
  astBuilder.InterfaceTypeDefinition({
    name: "Node",
    fields: [
      astBuilder.FieldDefinition({
        name: "id",
        type: astBuilder.TYPES.ID,
        required: true
      })
    ]
  }),
  astBuilder.InterfaceTypeDefinition({
    name: "Document",
    fields: [
      astBuilder.FieldDefinition({
        name: "id",
        type: astBuilder.TYPES.ID,
        required: true
      }),
      astBuilder.FieldDefinition({
        name: "_sys",
        type: astBuilder.TYPES.SystemInfo
      }),
      astBuilder.FieldDefinition({
        name: "_values",
        type: astBuilder.TYPES.JSON,
        required: true
      })
    ]
  }),
  astBuilder.InterfaceTypeDefinition({
    name: "Connection",
    description: "A relay-compliant pagination connection",
    fields: [
      astBuilder.FieldDefinition({
        name: "totalCount",
        required: true,
        type: astBuilder.TYPES.Number
      }),
      astBuilder.FieldDefinition({
        name: "pageInfo",
        required: true,
        type: astBuilder.ObjectTypeDefinition({
          name: "PageInfo",
          fields: [
            astBuilder.FieldDefinition({
              name: "hasPreviousPage",
              required: true,
              type: astBuilder.TYPES.Boolean
            }),
            astBuilder.FieldDefinition({
              name: "hasNextPage",
              required: true,
              type: astBuilder.TYPES.Boolean
            }),
            astBuilder.FieldDefinition({
              name: "startCursor",
              required: true,
              type: astBuilder.TYPES.String
            }),
            astBuilder.FieldDefinition({
              name: "endCursor",
              required: true,
              type: astBuilder.TYPES.String
            })
          ]
        })
      })
    ]
  })
];
var scalarDefinitions = [
  astBuilder.ScalarTypeDefinition({
    name: "Reference",
    description: "References another document, used as a foreign key"
  }),
  astBuilder.ScalarTypeDefinition({ name: "JSON" }),
  astBuilder.ObjectTypeDefinition({
    name: "SystemInfo",
    fields: [
      astBuilder.FieldDefinition({
        name: "filename",
        required: true,
        type: astBuilder.TYPES.String
      }),
      astBuilder.FieldDefinition({
        name: "title",
        required: false,
        type: astBuilder.TYPES.String
      }),
      astBuilder.FieldDefinition({
        name: "basename",
        required: true,
        type: astBuilder.TYPES.String
      }),
      astBuilder.FieldDefinition({
        name: "breadcrumbs",
        required: true,
        type: astBuilder.TYPES.String,
        list: true,
        args: [
          astBuilder.InputValueDefinition({
            name: "excludeExtension",
            type: astBuilder.TYPES.Boolean
          })
        ]
      }),
      astBuilder.FieldDefinition({
        name: "path",
        required: true,
        type: astBuilder.TYPES.String
      }),
      astBuilder.FieldDefinition({
        name: "relativePath",
        required: true,
        type: astBuilder.TYPES.String
      }),
      astBuilder.FieldDefinition({
        name: "extension",
        required: true,
        type: astBuilder.TYPES.String
      }),
      astBuilder.FieldDefinition({
        name: "template",
        required: true,
        type: astBuilder.TYPES.String
      }),
      astBuilder.FieldDefinition({
        name: "collection",
        required: true,
        type: astBuilder.TYPES.Collection
      })
    ]
  }),
  astBuilder.ObjectTypeDefinition({
    name: "PageInfo",
    fields: [
      astBuilder.FieldDefinition({
        name: "hasPreviousPage",
        required: true,
        type: astBuilder.TYPES.Boolean
      }),
      astBuilder.FieldDefinition({
        name: "hasNextPage",
        required: true,
        type: astBuilder.TYPES.Boolean
      }),
      astBuilder.FieldDefinition({
        name: "startCursor",
        required: true,
        type: astBuilder.TYPES.String
      }),
      astBuilder.FieldDefinition({
        name: "endCursor",
        required: true,
        type: astBuilder.TYPES.String
      })
    ]
  })
];
var staticDefinitions = [...scalarDefinitions, interfaceDefinitions];

// src/builder/index.ts
var createBuilder = async ({
  database,
  tinaSchema
}) => {
  return new Builder({ database, tinaSchema });
};
var Builder = class {
  constructor(config) {
    this.config = config;
    this.buildCollectionDefinition = async (collections) => {
      const name2 = "collection";
      const typeName = "Collection";
      const args = [
        astBuilder.InputValueDefinition({
          name: "collection",
          type: astBuilder.TYPES.String
        })
      ];
      const documentsType = await this._buildMultiCollectionDocumentListDefinition({
        fieldName: "documents",
        namespace: ["document"],
        nodeType: astBuilder.TYPES.MultiCollectionDocument,
        collections,
        connectionNamespace: ["document"]
      });
      const type = astBuilder.ObjectTypeDefinition({
        name: typeName,
        fields: [
          astBuilder.FieldDefinition({
            name: "name",
            required: true,
            type: astBuilder.TYPES.String
          }),
          astBuilder.FieldDefinition({
            name: "slug",
            required: true,
            type: astBuilder.TYPES.String
          }),
          astBuilder.FieldDefinition({
            name: "label",
            required: false,
            type: astBuilder.TYPES.String
          }),
          astBuilder.FieldDefinition({
            name: "path",
            required: true,
            type: astBuilder.TYPES.String
          }),
          astBuilder.FieldDefinition({
            name: "format",
            required: false,
            type: astBuilder.TYPES.String
          }),
          astBuilder.FieldDefinition({
            name: "matches",
            required: false,
            type: astBuilder.TYPES.String
          }),
          astBuilder.FieldDefinition({
            name: "templates",
            list: true,
            type: "JSON"
          }),
          astBuilder.FieldDefinition({
            name: "fields",
            list: true,
            type: "JSON"
          }),
          documentsType
        ]
      });
      return astBuilder.FieldDefinition({
        type,
        name: name2,
        args,
        required: true
      });
    };
    this.buildMultiCollectionDefinition = async (collections) => {
      const name2 = "collections";
      const typeName = "Collection";
      return astBuilder.FieldDefinition({
        type: typeName,
        name: name2,
        list: true,
        required: true
      });
    };
    this.multiNodeDocument = async () => {
      const name2 = "node";
      const args = [
        astBuilder.InputValueDefinition({
          name: "id",
          type: astBuilder.TYPES.String
        })
      ];
      await this.database.addToLookupMap({
        type: astBuilder.TYPES.Node,
        resolveType: "nodeDocument"
      });
      return astBuilder.FieldDefinition({
        name: name2,
        args,
        list: false,
        type: astBuilder.TYPES.Node,
        required: true
      });
    };
    this.multiCollectionDocument = async (collections) => {
      const name2 = "document";
      const args = [
        astBuilder.InputValueDefinition({
          name: "collection",
          type: astBuilder.TYPES.String
        }),
        astBuilder.InputValueDefinition({
          name: "relativePath",
          type: astBuilder.TYPES.String
        })
      ];
      const type = await this._buildMultiCollectionDocumentDefinition({
        fieldName: astBuilder.TYPES.MultiCollectionDocument,
        collections
      });
      return astBuilder.FieldDefinition({
        name: name2,
        args,
        list: false,
        type,
        required: true
      });
    };
    this.addMultiCollectionDocumentMutation = async () => {
      return astBuilder.FieldDefinition({
        name: "addPendingDocument",
        args: [
          astBuilder.InputValueDefinition({
            name: "collection",
            required: true,
            type: astBuilder.TYPES.String
          }),
          astBuilder.InputValueDefinition({
            name: "relativePath",
            required: true,
            type: astBuilder.TYPES.String
          }),
          astBuilder.InputValueDefinition({
            name: "template",
            required: false,
            type: astBuilder.TYPES.String
          })
        ],
        required: true,
        type: astBuilder.TYPES.MultiCollectionDocument
      });
    };
    this.buildCreateCollectionDocumentMutation = async (collections) => {
      return astBuilder.FieldDefinition({
        name: "createDocument",
        args: [
          astBuilder.InputValueDefinition({
            name: "collection",
            required: false,
            type: astBuilder.TYPES.String
          }),
          astBuilder.InputValueDefinition({
            name: "relativePath",
            required: true,
            type: astBuilder.TYPES.String
          }),
          astBuilder.InputValueDefinition({
            name: "params",
            required: true,
            type: await this._buildReferenceMutation({
              namespace: ["document"],
              collections: collections.map((collection) => collection.name)
            })
          })
        ],
        required: true,
        type: astBuilder.TYPES.MultiCollectionDocument
      });
    };
    this.buildUpdateCollectionDocumentMutation = async (collections) => {
      return astBuilder.FieldDefinition({
        name: "updateDocument",
        args: [
          astBuilder.InputValueDefinition({
            name: "collection",
            required: false,
            type: astBuilder.TYPES.String
          }),
          astBuilder.InputValueDefinition({
            name: "relativePath",
            required: true,
            type: astBuilder.TYPES.String
          }),
          astBuilder.InputValueDefinition({
            name: "params",
            required: true,
            type: await this._buildUpdateDocumentMutationParams({
              namespace: ["document"],
              collections: collections.map((collection) => collection.name)
            })
          })
        ],
        required: true,
        type: astBuilder.TYPES.MultiCollectionDocument
      });
    };
    this.buildDeleteCollectionDocumentMutation = async (collections) => {
      return astBuilder.FieldDefinition({
        name: "deleteDocument",
        args: [
          astBuilder.InputValueDefinition({
            name: "collection",
            required: false,
            type: astBuilder.TYPES.String
          }),
          astBuilder.InputValueDefinition({
            name: "relativePath",
            required: true,
            type: astBuilder.TYPES.String
          })
        ],
        required: true,
        type: astBuilder.TYPES.MultiCollectionDocument
      });
    };
    this.collectionDocument = async (collection) => {
      const name2 = NAMER.queryName([collection.name]);
      const type = await this._buildCollectionDocumentType(collection);
      const args = [
        astBuilder.InputValueDefinition({
          name: "relativePath",
          type: astBuilder.TYPES.String
        })
      ];
      await this.database.addToLookupMap({
        type: type.name.value,
        resolveType: "collectionDocument",
        collection: collection.name,
        [NAMER.createName([collection.name])]: "create",
        [NAMER.updateName([collection.name])]: "update"
      });
      return astBuilder.FieldDefinition({ type, name: name2, args, required: true });
    };
    this.collectionFragment = async (collection) => {
      const name2 = NAMER.dataTypeName(collection.namespace);
      const fragmentName = NAMER.fragmentName(collection.namespace);
      const selections = await this._getCollectionFragmentSelections(collection, 0);
      return astBuilder.FragmentDefinition({
        name: name2,
        fragmentName,
        selections: filterSelections(selections)
      });
    };
    this._getCollectionFragmentSelections = async (collection, depth) => {
      const selections = [];
      if (typeof collection.fields === "object") {
        await sequential(collection.fields, async (x) => {
          const field = await this._buildFieldNodeForFragments(x, depth);
          selections.push(field);
        });
      } else {
        await sequential(collection.templates, async (tem) => {
          if (typeof tem === "object") {
            selections.push(await this.buildTemplateFragments(tem, depth));
          }
        });
      }
      return selections;
    };
    this._buildFieldNodeForFragments = async (field, depth) => {
      switch (field.type) {
        case "string":
        case "image":
        case "datetime":
        case "number":
        case "boolean":
        case "rich-text":
          return astBuilder.FieldNodeDefinition(field);
        case "object":
          if (typeof field.fields === "object") {
            const selections2 = [];
            await sequential(field.fields, async (item) => {
              const field2 = await this._buildFieldNodeForFragments(item, depth);
              selections2.push(field2);
            });
            return astBuilder.FieldWithSelectionSetDefinition({
              name: field.name,
              selections: [
                { kind: "Field", name: { kind: "Name", value: "__typename" } },
                ...filterSelections(selections2)
              ]
            });
          } else if (typeof field.templates === "object") {
            const selections2 = [];
            await sequential(field.templates, async (tem) => {
              if (typeof tem === "object") {
                selections2.push(await this.buildTemplateFragments(tem, depth));
              }
            });
            return astBuilder.FieldWithSelectionSetDefinition({
              name: field.name,
              selections: [
                { kind: "Field", name: { kind: "Name", value: "__typename" } },
                ...filterSelections(selections2)
              ]
            });
          }
        case "reference":
          if (depth >= this.maxDepth)
            return false;
          if (!("collections" in field)) {
            return false;
          }
          const selections = [];
          await sequential(field.collections, async (col) => {
            const collection = this.tinaSchema.getCollection(col);
            selections.push({
              kind: "InlineFragment",
              typeCondition: {
                kind: "NamedType",
                name: {
                  kind: "Name",
                  value: NAMER.documentTypeName(collection.namespace)
                }
              },
              directives: [],
              selectionSet: {
                kind: "SelectionSet",
                selections: filterSelections(await this._getCollectionFragmentSelections(collection, depth + 1))
              }
            });
          });
          return astBuilder.FieldWithSelectionSetDefinition({
            name: field.name,
            selections: [
              ...selections,
              {
                kind: "InlineFragment",
                typeCondition: {
                  kind: "NamedType",
                  name: {
                    kind: "Name",
                    value: "Document"
                  }
                },
                directives: [],
                selectionSet: {
                  kind: "SelectionSet",
                  selections: [
                    {
                      kind: "Field",
                      name: {
                        kind: "Name",
                        value: "id"
                      },
                      arguments: [],
                      directives: []
                    }
                  ]
                }
              }
            ]
          });
      }
    };
    this.updateCollectionDocumentMutation = async (collection) => {
      return astBuilder.FieldDefinition({
        type: await this._buildCollectionDocumentType(collection),
        name: NAMER.updateName([collection.name]),
        required: true,
        args: [
          astBuilder.InputValueDefinition({
            name: "relativePath",
            required: true,
            type: astBuilder.TYPES.String
          }),
          astBuilder.InputValueDefinition({
            name: "params",
            required: true,
            type: await this._updateCollectionDocumentMutationType(collection)
          })
        ]
      });
    };
    this.createCollectionDocumentMutation = async (collection) => {
      return astBuilder.FieldDefinition({
        type: await this._buildCollectionDocumentType(collection),
        name: NAMER.createName([collection.name]),
        required: true,
        args: [
          astBuilder.InputValueDefinition({
            name: "relativePath",
            required: true,
            type: astBuilder.TYPES.String
          }),
          astBuilder.InputValueDefinition({
            name: "params",
            required: true,
            type: await this._updateCollectionDocumentMutationType(collection)
          })
        ]
      });
    };
    this.collectionDocumentList = async (collection) => {
      const connectionName = NAMER.referenceConnectionType(collection.namespace);
      await this.database.addToLookupMap({
        type: connectionName,
        resolveType: "collectionDocumentList",
        collection: collection.name
      });
      return this._connectionFieldBuilder({
        fieldName: NAMER.generateQueryListName(collection.namespace),
        connectionName,
        nodeType: NAMER.documentTypeName(collection.namespace),
        namespace: collection.namespace,
        collection
      });
    };
    this.buildStaticDefinitions = () => staticDefinitions;
    this._buildCollectionDocumentType = async (collection, suffix = "", extraFields = [], extraInterfaces = []) => {
      const documentTypeName = NAMER.documentTypeName(collection.namespace);
      const templateInfo = this.tinaSchema.getTemplatesForCollectable(collection);
      if (templateInfo.type === "union") {
        return this._buildObjectOrUnionData(__spreadValues({}, templateInfo), [
          astBuilder.FieldDefinition({
            name: "id",
            required: true,
            type: astBuilder.TYPES.ID
          }),
          astBuilder.FieldDefinition({
            name: "_sys",
            required: true,
            type: astBuilder.TYPES.SystemInfo
          }),
          ...extraFields,
          astBuilder.FieldDefinition({
            name: "_values",
            required: true,
            type: "JSON"
          })
        ], [
          astBuilder.NamedType({ name: astBuilder.TYPES.Node }),
          astBuilder.NamedType({ name: astBuilder.TYPES.Document }),
          ...extraInterfaces
        ], collection);
      }
      const fields = templateInfo.template.fields;
      const templateFields = await sequential(fields, async (field) => {
        return this._buildDataField(field);
      });
      return astBuilder.ObjectTypeDefinition({
        name: documentTypeName + suffix,
        interfaces: [
          astBuilder.NamedType({ name: astBuilder.TYPES.Node }),
          astBuilder.NamedType({ name: astBuilder.TYPES.Document }),
          ...extraInterfaces
        ],
        fields: [
          ...templateFields,
          astBuilder.FieldDefinition({
            name: "id",
            required: true,
            type: astBuilder.TYPES.ID
          }),
          astBuilder.FieldDefinition({
            name: "_sys",
            required: true,
            type: astBuilder.TYPES.SystemInfo
          }),
          ...extraFields,
          astBuilder.FieldDefinition({
            name: "_values",
            required: true,
            type: "JSON"
          })
        ]
      });
    };
    this._filterCollectionDocumentType = async (collection) => {
      const t = this.tinaSchema.getTemplatesForCollectable(collection);
      if (t.type === "union") {
        return astBuilder.InputObjectTypeDefinition({
          name: NAMER.dataFilterTypeName(t.namespace),
          fields: await sequential(t.templates, async (template) => {
            return astBuilder.InputValueDefinition({
              name: template.namespace[template.namespace.length - 1],
              type: await this._buildTemplateFilter(template)
            });
          })
        });
      }
      return this._buildTemplateFilter(t.template);
    };
    this._buildTemplateFilter = async (template) => {
      const fields = [];
      await sequential(template.fields, async (field) => {
        const f = await this._buildFieldFilter(field);
        if (f) {
          fields.push(f);
        }
        return true;
      });
      return astBuilder.InputObjectTypeDefinition({
        name: NAMER.dataFilterTypeName(template.namespace),
        fields
      });
    };
    this._updateCollectionDocumentMutationType = async (collection) => {
      const t = this.tinaSchema.getTemplatesForCollectable(collection);
      if (t.type === "union") {
        return astBuilder.InputObjectTypeDefinition({
          name: NAMER.dataMutationTypeName(t.namespace),
          fields: await sequential(t.templates, async (template) => {
            return astBuilder.InputValueDefinition({
              name: template.namespace[template.namespace.length - 1],
              type: await this._buildTemplateMutation(template)
            });
          })
        });
      }
      return this._buildTemplateMutation(t.template);
    };
    this._buildTemplateMutation = async (template) => {
      return astBuilder.InputObjectTypeDefinition({
        name: NAMER.dataMutationTypeName(template.namespace),
        fields: await sequential(template.fields, (field) => {
          return this._buildFieldMutation(field);
        })
      });
    };
    this._buildMultiCollectionDocumentDefinition = async ({
      fieldName,
      collections
    }) => {
      const types = [];
      collections.forEach((collection) => {
        if (collection.fields) {
          const typeName = NAMER.documentTypeName(collection.namespace);
          types.push(typeName);
        }
        if (collection.templates) {
          collection.templates.forEach((template) => {
            if (typeof template === "string") {
              throw new Error("Global templates not yet supported");
            }
            const typeName = NAMER.documentTypeName(template.namespace);
            types.push(typeName);
          });
        }
      });
      const type = astBuilder.UnionTypeDefinition({
        name: fieldName,
        types
      });
      await this.database.addToLookupMap({
        type: type.name.value,
        resolveType: "multiCollectionDocument",
        createDocument: "create",
        updateDocument: "update"
      });
      return type;
    };
    this._buildMultiCollectionDocumentListDefinition = async ({
      fieldName,
      namespace,
      nodeType,
      collections,
      connectionNamespace
    }) => {
      const connectionName = NAMER.referenceConnectionType(namespace);
      await this.database.addToLookupMap({
        type: connectionName,
        resolveType: "multiCollectionDocumentList",
        collections: collections.map((collection) => collection.name)
      });
      return this._connectionFieldBuilder({
        fieldName,
        namespace: connectionNamespace,
        connectionName,
        nodeType,
        collections
      });
    };
    this._buildFieldFilter = async (field) => {
      switch (field.type) {
        case "boolean":
          return astBuilder.InputValueDefinition({
            name: field.name,
            type: astBuilder.InputObjectTypeDefinition({
              name: NAMER.dataFilterTypeName([field.type]),
              fields: [
                astBuilder.InputValueDefinition({
                  name: "eq",
                  type: astBuilder.TYPES.Boolean
                }),
                astBuilder.InputValueDefinition({
                  name: "exists",
                  type: astBuilder.TYPES.Boolean
                })
              ]
            })
          });
        case "number":
          return astBuilder.InputValueDefinition({
            name: field.name,
            type: astBuilder.InputObjectTypeDefinition({
              name: NAMER.dataFilterTypeName([field.type]),
              fields: [
                astBuilder.InputValueDefinition({
                  name: "lt",
                  type: astBuilder.TYPES.Number
                }),
                astBuilder.InputValueDefinition({
                  name: "lte",
                  type: astBuilder.TYPES.Number
                }),
                astBuilder.InputValueDefinition({
                  name: "gte",
                  type: astBuilder.TYPES.Number
                }),
                astBuilder.InputValueDefinition({
                  name: "gt",
                  type: astBuilder.TYPES.Number
                }),
                astBuilder.InputValueDefinition({
                  name: "eq",
                  type: astBuilder.TYPES.Number
                }),
                astBuilder.InputValueDefinition({
                  name: "exists",
                  type: astBuilder.TYPES.Boolean
                }),
                astBuilder.InputValueDefinition({
                  name: "in",
                  type: astBuilder.TYPES.Number,
                  list: true
                })
              ]
            })
          });
        case "datetime":
          return astBuilder.InputValueDefinition({
            name: field.name,
            type: astBuilder.InputObjectTypeDefinition({
              name: NAMER.dataFilterTypeName([field.type]),
              fields: [
                astBuilder.InputValueDefinition({
                  name: "after",
                  type: astBuilder.TYPES.String
                }),
                astBuilder.InputValueDefinition({
                  name: "before",
                  type: astBuilder.TYPES.String
                }),
                astBuilder.InputValueDefinition({
                  name: "eq",
                  type: astBuilder.TYPES.String
                }),
                astBuilder.InputValueDefinition({
                  name: "exists",
                  type: astBuilder.TYPES.Boolean
                }),
                astBuilder.InputValueDefinition({
                  name: "in",
                  type: astBuilder.TYPES.String,
                  list: true
                })
              ]
            })
          });
        case "image":
        case "string":
          return astBuilder.InputValueDefinition({
            name: field.name,
            type: astBuilder.InputObjectTypeDefinition({
              name: NAMER.dataFilterTypeName([field.type]),
              fields: [
                astBuilder.InputValueDefinition({
                  name: "startsWith",
                  type: astBuilder.TYPES.String
                }),
                astBuilder.InputValueDefinition({
                  name: "eq",
                  type: astBuilder.TYPES.String
                }),
                astBuilder.InputValueDefinition({
                  name: "exists",
                  type: astBuilder.TYPES.Boolean
                }),
                astBuilder.InputValueDefinition({
                  name: "in",
                  type: astBuilder.TYPES.String,
                  list: true
                })
              ]
            })
          });
        case "object":
          return astBuilder.InputValueDefinition({
            name: field.name,
            type: await this._filterCollectionDocumentType(field)
          });
        case "rich-text":
          if (!field.templates || field.templates.length === 0) {
            return astBuilder.InputValueDefinition({
              name: field.name,
              type: astBuilder.InputObjectTypeDefinition({
                name: NAMER.dataFilterTypeName(["richText"]),
                fields: [
                  astBuilder.InputValueDefinition({
                    name: "startsWith",
                    type: astBuilder.TYPES.String
                  }),
                  astBuilder.InputValueDefinition({
                    name: "eq",
                    type: astBuilder.TYPES.String
                  }),
                  astBuilder.InputValueDefinition({
                    name: "exists",
                    type: astBuilder.TYPES.Boolean
                  })
                ]
              })
            });
          }
          return astBuilder.InputValueDefinition({
            name: field.name,
            type: await this._filterCollectionDocumentType(field)
          });
        case "reference":
          const filter = await this._connectionFilterBuilder({
            fieldName: field.name,
            namespace: field.namespace,
            collections: await this.tinaSchema.getCollectionsByName(field.collections)
          });
          return astBuilder.InputValueDefinition({
            name: field.name,
            type: astBuilder.InputObjectTypeDefinition({
              name: NAMER.dataFilterTypeName(field.namespace),
              fields: [filter]
            })
          });
      }
    };
    this._buildFieldMutation = async (field) => {
      switch (field.type) {
        case "boolean":
          return astBuilder.InputValueDefinition({
            name: field.name,
            list: field.list,
            type: astBuilder.TYPES.Boolean
          });
        case "number":
          return astBuilder.InputValueDefinition({
            name: field.name,
            list: field.list,
            type: astBuilder.TYPES.Number
          });
        case "datetime":
        case "image":
        case "string":
          return astBuilder.InputValueDefinition({
            name: field.name,
            list: field.list,
            type: astBuilder.TYPES.String
          });
        case "object":
          return astBuilder.InputValueDefinition({
            name: field.name,
            list: field.list,
            type: await this._updateCollectionDocumentMutationType(field)
          });
        case "rich-text":
          return astBuilder.InputValueDefinition({
            name: field.name,
            list: field.list,
            type: astBuilder.TYPES.JSON
          });
        case "reference":
          return astBuilder.InputValueDefinition({
            name: field.name,
            list: field.list,
            type: astBuilder.TYPES.String
          });
      }
    };
    this._buildReferenceMutation = async (field) => {
      return astBuilder.InputObjectTypeDefinition({
        name: NAMER.dataMutationTypeName(field.namespace),
        fields: await sequential(this.tinaSchema.getCollectionsByName(field.collections), async (collection) => {
          return astBuilder.InputValueDefinition({
            name: collection.name,
            type: NAMER.dataMutationTypeName([collection.name])
          });
        })
      });
    };
    this._buildUpdateDocumentMutationParams = async (field) => {
      const fields = await sequential(this.tinaSchema.getCollectionsByName(field.collections), async (collection) => {
        return astBuilder.InputValueDefinition({
          name: collection.name,
          type: NAMER.dataMutationTypeName([collection.name])
        });
      });
      fields.push(astBuilder.InputValueDefinition({
        name: "relativePath",
        type: astBuilder.TYPES.String
      }));
      return astBuilder.InputObjectTypeDefinition({
        name: NAMER.dataMutationUpdateTypeName(field.namespace),
        fields
      });
    };
    this._buildObjectOrUnionData = async (collectableTemplate, extraFields = [], extraInterfaces = [], collection) => {
      if (collectableTemplate.type === "union") {
        const name2 = NAMER.dataTypeName(collectableTemplate.namespace);
        const typeMap = {};
        const types = await sequential(collectableTemplate.templates, async (template) => {
          const type = await this._buildTemplateData(template, extraFields, extraInterfaces);
          typeMap[template.namespace[template.namespace.length - 1]] = type.name.value;
          return type;
        });
        await this.database.addToLookupMap({
          type: name2,
          resolveType: "unionData",
          collection: collection == null ? void 0 : collection.name,
          typeMap
        });
        return astBuilder.UnionTypeDefinition({ name: name2, types });
      }
      return this._buildTemplateData(collectableTemplate.template);
    };
    this._connectionFilterBuilder = async ({
      fieldName,
      namespace,
      collection,
      collections
    }) => {
      let filter;
      if (collections) {
        filter = astBuilder.InputValueDefinition({
          name: "filter",
          type: astBuilder.InputObjectTypeDefinition({
            name: NAMER.dataFilterTypeName(namespace),
            fields: await sequential(collections, async (collection2) => {
              return astBuilder.InputValueDefinition({
                name: collection2.name,
                type: NAMER.dataFilterTypeName(collection2.namespace)
              });
            })
          })
        });
      } else if (collection) {
        filter = astBuilder.InputValueDefinition({
          name: "filter",
          type: await this._filterCollectionDocumentType(collection)
        });
      } else {
        throw new Error(`Must provide either collection or collections to filter field builder`);
      }
      return filter;
    };
    this._connectionFieldBuilder = async ({
      fieldName,
      namespace,
      connectionName,
      nodeType,
      collection,
      collections
    }) => {
      const extra = this.database.store.supportsIndexing() ? [
        await this._connectionFilterBuilder({
          fieldName,
          namespace,
          collection,
          collections
        })
      ] : [];
      return astBuilder.FieldDefinition({
        name: fieldName,
        required: true,
        args: [...listArgs, ...extra],
        type: astBuilder.ObjectTypeDefinition({
          name: connectionName,
          interfaces: [
            astBuilder.NamedType({ name: astBuilder.TYPES.Connection })
          ],
          fields: [
            astBuilder.FieldDefinition({
              name: "pageInfo",
              required: true,
              type: astBuilder.TYPES.PageInfo
            }),
            astBuilder.FieldDefinition({
              name: "totalCount",
              required: true,
              type: astBuilder.TYPES.Number
            }),
            astBuilder.FieldDefinition({
              name: "edges",
              list: true,
              type: astBuilder.ObjectTypeDefinition({
                name: NAMER.referenceConnectionEdgesTypeName(namespace),
                fields: [
                  astBuilder.FieldDefinition({
                    name: "cursor",
                    required: true,
                    type: astBuilder.TYPES.String
                  }),
                  astBuilder.FieldDefinition({ name: "node", type: nodeType })
                ]
              })
            })
          ]
        })
      });
    };
    this._buildDataField = async (field) => {
      const listWarningMsg = `
WARNING: The user interface for ${field.type} does not support \`list: true\`
Visit https://tina.io/docs/errors/ui-not-supported/ for more information

`;
      switch (field.type) {
        case "boolean":
        case "datetime":
        case "image":
        case "number":
          if (field.list) {
            console.warn(listWarningMsg);
          }
        case "string":
          return astBuilder.FieldDefinition({
            name: field.name,
            list: field.list,
            required: field.required,
            type: astBuilder.TYPES.Scalar(field.type)
          });
        case "object":
          return astBuilder.FieldDefinition({
            name: field.name,
            list: field.list,
            required: field.required,
            type: await this._buildObjectOrUnionData(this.tinaSchema.getTemplatesForCollectable(field))
          });
        case "rich-text":
          return astBuilder.FieldDefinition({
            name: field.name,
            list: field.list,
            required: field.required,
            type: astBuilder.TYPES.JSON
          });
        case "reference":
          const name2 = NAMER.documentTypeName(field.namespace);
          if (field.list) {
            console.warn(listWarningMsg);
            return this._buildMultiCollectionDocumentListDefinition({
              fieldName: field.name,
              namespace: field.namespace,
              nodeType: astBuilder.UnionTypeDefinition({
                name: name2,
                types: field.collections.map((collectionName) => NAMER.documentTypeName([collectionName]))
              }),
              collections: this.tinaSchema.getCollectionsByName(field.collections),
              connectionNamespace: field.namespace
            });
          } else {
            const type = await this._buildMultiCollectionDocumentDefinition({
              fieldName: name2,
              collections: this.tinaSchema.getCollectionsByName(field.collections)
            });
            return astBuilder.FieldDefinition({
              name: field.name,
              required: field.required,
              list: false,
              type
            });
          }
      }
    };
    this._buildTemplateData = async ({ namespace, fields }, extraFields = [], extraInterfaces = []) => {
      return astBuilder.ObjectTypeDefinition({
        name: NAMER.dataTypeName(namespace),
        interfaces: extraInterfaces || [],
        fields: [
          ...await sequential(fields, async (field) => {
            return this._buildDataField(field);
          }),
          ...extraFields
        ]
      });
    };
    var _a, _b, _c, _d;
    this.maxDepth = (_d = (_c = (_b = (_a = config == null ? void 0 : config.tinaSchema.schema) == null ? void 0 : _a.config) == null ? void 0 : _b.client) == null ? void 0 : _c.referenceDepth) != null ? _d : 2;
    this.tinaSchema = config.tinaSchema;
    this.database = config.database;
  }
  async buildTemplateFragments(template, depth) {
    const selections = [];
    await sequential(template.fields || [], async (item) => {
      const field = await this._buildFieldNodeForFragments(item, depth);
      selections.push(field);
    });
    const filteredSelections = filterSelections(selections);
    if (!filteredSelections.length)
      return false;
    return astBuilder.InlineFragmentDefinition({
      selections: filteredSelections,
      name: NAMER.dataTypeName(template.namespace)
    });
  }
};
var listArgs = [
  astBuilder.InputValueDefinition({
    name: "before",
    type: astBuilder.TYPES.String
  }),
  astBuilder.InputValueDefinition({
    name: "after",
    type: astBuilder.TYPES.String
  }),
  astBuilder.InputValueDefinition({
    name: "first",
    type: astBuilder.TYPES.Number
  }),
  astBuilder.InputValueDefinition({
    name: "last",
    type: astBuilder.TYPES.Number
  }),
  astBuilder.InputValueDefinition({
    name: "sort",
    type: astBuilder.TYPES.String
  })
];
var filterSelections = (arr) => {
  return arr.filter(Boolean);
};

// src/schema/createSchema.ts
var import_schema_tools2 = __toModule(require("@tinacms/schema-tools"));

// src/schema/validate.ts
var import_lodash2 = __toModule(require("lodash"));
var yup2 = __toModule(require("yup"));
var import_schema_tools = __toModule(require("@tinacms/schema-tools"));
var FIELD_TYPES = [
  "string",
  "number",
  "boolean",
  "datetime",
  "image",
  "reference",
  "object",
  "rich-text"
];
var validateSchema = async (schema) => {
  const schema2 = addNamespaceToSchema(import_lodash2.default.cloneDeep(schema));
  const collections = await sequential(schema2.collections, async (collection) => validateCollection(collection));
  validationCollectionsPathAndMatch(collections);
  if (schema2.config) {
    const config = (0, import_schema_tools.validateTinaCloudSchemaConfig)(schema2.config);
    return {
      collections,
      config
    };
  }
  return {
    collections
  };
};
var validationCollectionsPathAndMatch = (collections) => {
  const paths = collections.map((x) => x.path);
  if (paths.length === new Set(paths).size) {
    return;
  }
  const noMatchCollections = collections.filter((x) => {
    return typeof (x == null ? void 0 : x.match) === "undefined";
  }).map((x) => x.path);
  if (noMatchCollections.length !== new Set(noMatchCollections).size) {
    throw new Error("path must be unique");
  }
  const hasMatchAndPath = collections.filter((x) => {
    return typeof x.path !== "undefined" && typeof x.match !== "undefined";
  }).map((x) => `${x.path}|${x.match}`);
  if (hasMatchAndPath.length !== new Set(hasMatchAndPath).size) {
    throw new Error("Both `match` and `path` can not be the same");
  }
  const groupbyPath = collections.reduce((r, a) => {
    r[a.path] = r[a.path] || [];
    r[a.path].push(a);
    return r;
  }, Object.create(null));
  Object.keys(groupbyPath).forEach((key) => {
    const collectionsArr = groupbyPath[key];
    if (collectionsArr.length === 1) {
      return;
    }
    const matches = collectionsArr.filter((x) => {
      return typeof x.match !== "undefined";
    });
    if (matches.length !== collections.length) {
      throw new Error("path must be unique when no `match` is provided");
    }
  });
};
var validateCollection = async (collection) => {
  let templates = [];
  let fields = [];
  const messageName = collection.namespace.join(".");
  const collectionSchema = yup2.object({
    name: yup2.string().matches(/^[a-zA-Z0-9_]*$/, {
      message: (obj) => `Collection's "name" must match ${obj.regex} at ${messageName}`
    }).required(),
    path: yup2.string().required().transform((value) => {
      return value.replace(/^\/|\/$/g, "");
    })
  });
  await collectionSchema.validate(collection);
  const validCollection = await collectionSchema.cast(collection);
  if (validCollection.templates) {
    templates = await sequential(validCollection.templates, async (template) => {
      if (typeof template === "string") {
        throw new Error(`Global templates are not yet supported`);
      }
      const fields2 = await sequential(template.fields, async (field) => {
        return validateField(field);
      });
      return __spreadValues(__spreadValues({}, validCollection), fields2);
    });
  }
  if (validCollection.fields) {
    if (typeof validCollection.fields === "string") {
      throw new Error(`Global templates are not yet supported`);
    }
    fields = await sequential(validCollection.fields, async (field) => {
      return validateField(field);
    });
    return __spreadProps(__spreadValues({}, validCollection), {
      fields
    });
  }
  return collection;
};
var validateField = async (field) => {
  const messageName = field.namespace.join(".");
  const schema = yup2.object({
    name: yup2.string().matches(/^[a-zA-Z0-9_]*$/, {
      message: (obj) => `Field's 'name' must match ${obj.regex} at ${messageName}`
    }).required(),
    type: yup2.string().oneOf(FIELD_TYPES, (obj) => `'type' must be one of: ${obj.values}, but got '${obj.value}' at ${messageName}`)
  });
  await schema.validate(field);
  return field;
};

// package.json
var name = "@tinacms/graphql";
var version = "1.1.0";
var main = "dist/index.js";
var typings = "dist/index.d.ts";
var files = [
  "package.json",
  "dist"
];
var license = "Apache-2.0";
var buildConfig = {
  entryPoints: [
    {
      name: "src/index.ts",
      target: "node",
      bundle: []
    }
  ]
};
var scripts = {
  types: "pnpm tsc",
  build: "tinacms-scripts build",
  docs: "yarn typedoc",
  serve: "yarn nodemon dist/server.js",
  test: "jest",
  "test-watch": "jest --watch"
};
var dependencies = {
  "@graphql-tools/relay-operation-optimizer": "^6.4.1",
  "@iarna/toml": "^2.2.5",
  "@tinacms/datalayer": "workspace:*",
  "@tinacms/mdx": "workspace:*",
  "@tinacms/schema-tools": "workspace:*",
  "body-parser": "^1.19.0",
  cors: "^2.8.5",
  dataloader: "^2.0.0",
  "date-fns": "^2.21.1",
  "encoding-down": "^7.1.0",
  esbuild: "^0.12.25",
  "esbuild-jest": "^0.5.0",
  "estree-walker": "^3.0.0",
  "fast-glob": "^3.2.5",
  flat: "^5.0.2",
  "fs-extra": "^9.0.1",
  graphql: "15.8.0",
  "graphql-type-json": "^0.3.2",
  "gray-matter": "^4.0.2",
  "js-yaml": "^3.14.1",
  leveldown: "^6.1.0",
  lodash: "^4.17.20",
  mdast: "^3.0.0",
  "mdast-util-from-markdown": "^1.0.0",
  "mdast-util-mdx": "^1.1.0",
  "mdast-util-mdx-expression": "^1.1.0",
  "mdast-util-to-markdown": "^1.2.1",
  "micromark-extension-mdxjs": "^1.0.0",
  "normalize-path": "^3.0.0",
  prettier: "^2.2.1",
  "rehype-format": "^3.1.0",
  "rehype-stringify": "^8.0.0",
  remark: "^13.0.0",
  "remark-frontmatter": "^3.0.0",
  "remark-mdx": "next",
  "remark-parse": "^10.0.0",
  "remark-rehype": "^8.0.0",
  "remark-slate": "^1.8.0",
  "remark-stringify": "^8.1.1",
  unified: "^10.1.0",
  "unist-util-remove-position": "^3.0.0",
  "unist-util-visit": "^4.0.0",
  vfile: "^4.2.0",
  ws: "^7.3.1",
  yup: "^0.32.9"
};
var publishConfig = {
  registry: "https://registry.npmjs.org"
};
var repository = {
  url: "https://github.com/tinacms/tinacms.git",
  directory: "packages/tina-graphql"
};
var devDependencies = {
  "@tinacms/datalayer": "workspace:*",
  "@tinacms/schema-tools": "workspace:*",
  "@tinacms/scripts": "workspace:*",
  "@types/cors": "^2.8.7",
  "@types/estree": "^0.0.50",
  "@types/express": "^4.17.8",
  "@types/fs-extra": "^9.0.2",
  "@types/jest": "^26.0.4",
  "@types/js-yaml": "^3.12.5",
  "@types/lodash": "^4.14.161",
  "@types/lodash.camelcase": "^4.3.6",
  "@types/lodash.upperfirst": "^4.3.6",
  "@types/lru-cache": "^5.1.0",
  "@types/mdast": "^3.0.10",
  "@types/node": "^14.17.34",
  "@types/normalize-path": "^3.0.0",
  "@types/ws": "^7.2.6",
  "@types/yup": "^0.29.7",
  jest: "27.0.6",
  "jest-diff": "27.0.6",
  "jest-file-snapshot": "^0.5.0",
  "jest-matcher-utils": "27.0.6",
  nodemon: "2.0.19",
  typescript: "4.3.5"
};
var package_default = {
  name,
  version,
  main,
  typings,
  files,
  license,
  buildConfig,
  scripts,
  dependencies,
  publishConfig,
  repository,
  devDependencies
};

// src/schema/createSchema.ts
var createSchema = async ({
  schema,
  flags = []
}) => {
  const validSchema = await validateSchema(schema);
  const [major, minor, patch] = package_default.version.split(".");
  const meta = {};
  if (flags && flags.length > 0) {
    meta["flags"] = flags;
  }
  return new import_schema_tools2.TinaSchema(__spreadValues({
    version: {
      fullVersion: package_default.version,
      major,
      minor,
      patch
    },
    meta
  }, validSchema));
};

// src/build.ts
var import_path = __toModule(require("path"));
var buildDotTinaFiles = async ({
  database,
  config,
  flags = [],
  buildSDK = true
}) => {
  if (database.store.supportsIndexing()) {
    if (flags.indexOf("experimentalData") === -1) {
      flags.push("experimentalData");
    }
  }
  const tinaSchema = await createSchema({ schema: config, flags });
  const builder = await createBuilder({
    database,
    tinaSchema
  });
  let graphQLSchema;
  if (database.bridge.supportsBuilding()) {
    graphQLSchema = await _buildSchema(builder, tinaSchema);
    await database.putConfigFiles({ graphQLSchema, tinaSchema });
  } else {
    graphQLSchema = JSON.parse(await database.bridge.get(".tina/__generated__/_graphql.json"));
  }
  if (buildSDK) {
    await _buildFragments(builder, tinaSchema, database.bridge.rootPath);
    await _buildQueries(builder, tinaSchema, database.bridge.rootPath);
  }
  return { graphQLSchema, tinaSchema };
};
var _buildFragments = async (builder, tinaSchema, rootPath) => {
  const fragmentDefinitionsFields = [];
  const collections = tinaSchema.getCollections();
  await sequential(collections, async (collection) => {
    const frag = await builder.collectionFragment(collection);
    fragmentDefinitionsFields.push(frag);
  });
  const fragDoc = {
    kind: "Document",
    definitions: import_lodash3.default.uniqBy(extractInlineTypes(fragmentDefinitionsFields), (node) => node.name.value)
  };
  const fragPath = import_path.default.join(rootPath, ".tina", "__generated__");
  await import_fs_extra.default.outputFile(import_path.default.join(fragPath, "frags.gql"), (0, import_graphql2.print)(fragDoc));
  if (await (await import_fs_extra.default.stat(import_path.default.join(fragPath, "frags.gql"))).size > 100 * 1024) {
    console.warn("Warning: frags.gql is very large (>100kb). Consider setting the reference depth to 1 or 0. See code snippet below.");
    console.log(`const schema = defineSchema({
        config: {
            client: {
                referenceDepth: 1,
            },
        }
        // ...
    })`);
  }
};
var _buildQueries = async (builder, tinaSchema, rootPath) => {
  const operationsDefinitions = [];
  const collections = tinaSchema.getCollections();
  await sequential(collections, async (collection) => {
    var _a, _b, _c;
    const queryName = NAMER.queryName(collection.namespace);
    const queryListName = NAMER.generateQueryListName(collection.namespace);
    const queryFilterTypeName = NAMER.dataFilterTypeName(collection.namespace);
    const fragName = NAMER.fragmentName(collection.namespace);
    operationsDefinitions.push(astBuilder.QueryOperationDefinition({ fragName, queryName }));
    operationsDefinitions.push(astBuilder.ListQueryOperationDefinition({
      fragName,
      queryName: queryListName,
      filterType: queryFilterTypeName,
      dataLayer: Boolean((_c = (_b = (_a = tinaSchema.config) == null ? void 0 : _a.meta) == null ? void 0 : _b.flags) == null ? void 0 : _c.find((x) => x === "experimentalData"))
    }));
  });
  const queryDoc = {
    kind: "Document",
    definitions: import_lodash3.default.uniqBy(extractInlineTypes(operationsDefinitions), (node) => node.name.value)
  };
  const fragPath = import_path.default.join(rootPath, ".tina", "__generated__");
  await import_fs_extra.default.outputFile(import_path.default.join(fragPath, "queries.gql"), (0, import_graphql2.print)(queryDoc));
};
var _buildSchema = async (builder, tinaSchema) => {
  const definitions = [];
  definitions.push(await builder.buildStaticDefinitions());
  const queryTypeDefinitionFields = [];
  const mutationTypeDefinitionFields = [];
  const collections = tinaSchema.getCollections();
  queryTypeDefinitionFields.push(astBuilder.FieldDefinition({
    name: "getOptimizedQuery",
    args: [
      astBuilder.InputValueDefinition({
        name: "queryString",
        type: astBuilder.TYPES.String,
        required: true
      })
    ],
    type: astBuilder.TYPES.String
  }));
  queryTypeDefinitionFields.push(await builder.buildCollectionDefinition(collections));
  queryTypeDefinitionFields.push(await builder.buildMultiCollectionDefinition(collections));
  queryTypeDefinitionFields.push(await builder.multiNodeDocument());
  queryTypeDefinitionFields.push(await builder.multiCollectionDocument(collections));
  mutationTypeDefinitionFields.push(await builder.addMultiCollectionDocumentMutation());
  mutationTypeDefinitionFields.push(await builder.buildUpdateCollectionDocumentMutation(collections));
  mutationTypeDefinitionFields.push(await builder.buildDeleteCollectionDocumentMutation(collections));
  mutationTypeDefinitionFields.push(await builder.buildCreateCollectionDocumentMutation(collections));
  await sequential(collections, async (collection) => {
    queryTypeDefinitionFields.push(await builder.collectionDocument(collection));
    mutationTypeDefinitionFields.push(await builder.updateCollectionDocumentMutation(collection));
    mutationTypeDefinitionFields.push(await builder.createCollectionDocumentMutation(collection));
    queryTypeDefinitionFields.push(await builder.collectionDocumentList(collection));
  });
  definitions.push(astBuilder.ObjectTypeDefinition({
    name: "Query",
    fields: queryTypeDefinitionFields
  }));
  definitions.push(astBuilder.ObjectTypeDefinition({
    name: "Mutation",
    fields: mutationTypeDefinitionFields
  }));
  const doc = {
    kind: "Document",
    definitions: import_lodash3.default.uniqBy(extractInlineTypes(definitions), (node) => node.name.value)
  };
  return doc;
};

// src/resolve.ts
var import_graphql4 = __toModule(require("graphql"));

// src/resolver/index.ts
var import_path2 = __toModule(require("path"));
var import_isValid = __toModule(require("date-fns/isValid"));

// src/mdx/index.ts
var import_mdx = __toModule(require("@tinacms/mdx"));

// src/resolver/error.ts
var TinaGraphQLError = class extends Error {
  constructor(message, extensions) {
    super(message);
    if (!this.name) {
      Object.defineProperty(this, "name", { value: "TinaGraphQLError" });
    }
    this.extensions = __spreadValues({}, extensions);
  }
};
var TinaFetchError = class extends Error {
  constructor(message, args) {
    super(message);
    this.name = "TinaFetchError";
    this.collection = args.collection;
    this.stack = args.stack;
    this.file = args.file;
    this.originalError = args.originalError;
  }
};
var TinaQueryError = class extends TinaFetchError {
  constructor(args) {
    super(`Error querying file ${args.file} from collection ${args.collection}. ${auditMessage(args.includeAuditMessage)}`, args);
  }
};
var TinaParseDocumentError = class extends TinaFetchError {
  constructor(args) {
    super(`Error Parsing file ${args.file} from collection ${args.collection}. ${auditMessage(args.includeAuditMessage)}`, args);
  }
  toString() {
    return super.toString() + "\n OriginalError: \n" + this.originalError.toString();
  }
};
var auditMessage = (includeAuditMessage = true) => includeAuditMessage ? `Please run "tinacms audit" or add the --verbose option  for more info` : "";
var handleFetchErrorError = (e, verbose) => {
  if (e instanceof Error) {
    if (e instanceof TinaFetchError) {
      if (verbose) {
        console.log(e.toString());
        console.log(e);
        console.log(e.stack);
      }
    }
  } else {
    console.error(e);
  }
  throw e;
};

// src/resolver/index.ts
var import_datalayer = __toModule(require("@tinacms/datalayer"));

// src/resolver/filter-utils.ts
var resolveReferences = async (filter, fields, resolver) => {
  for (const fieldKey of Object.keys(filter)) {
    const fieldDefinition = fields.find((f) => f.name === fieldKey);
    if (fieldDefinition) {
      if (fieldDefinition.type === "reference") {
        const { edges, values } = await resolver(filter, fieldDefinition);
        if (edges.length === 1) {
          filter[fieldKey] = {
            eq: values[0]
          };
        } else if (edges.length > 1) {
          filter[fieldKey] = {
            in: values
          };
        } else {
          filter[fieldKey] = {
            eq: "___null___"
          };
        }
      } else if (fieldDefinition.type === "object") {
        if (fieldDefinition.templates) {
          const globalTemplates = {};
          for (const template of fieldDefinition.templates) {
            if (typeof template === "string") {
              globalTemplates[template] = 1;
            }
          }
          for (const templateName of Object.keys(filter[fieldKey])) {
            if (templateName in globalTemplates) {
              throw new Error("Global templates not yet supported for queries");
            }
            const template = fieldDefinition.templates.find((template2) => !(typeof template2 === "string") && template2.name === templateName);
            if (template) {
              await resolveReferences(filter[fieldKey][templateName], template.fields, resolver);
            } else {
              throw new Error(`Template ${templateName} not found`);
            }
          }
        } else {
          await resolveReferences(filter[fieldKey], fieldDefinition.fields, resolver);
        }
      }
    } else {
      throw new Error(`Unable to find field ${fieldKey}`);
    }
  }
};
var collectConditionsForChildFields = (filterNode, fields, pathExpression, collectCondition) => {
  for (const childFieldName of Object.keys(filterNode)) {
    const childField = fields.find((field) => field.name === childFieldName);
    if (!childField) {
      throw new Error(`Unable to find type for field ${childFieldName}`);
    }
    collectConditionsForField(childFieldName, childField, filterNode[childFieldName], pathExpression, collectCondition);
  }
};
var collectConditionsForObjectField = (fieldName, field, filterNode, pathExpression, collectCondition) => {
  if (field.list && field.templates) {
    const globalTemplates = {};
    for (const template of field.templates) {
      if (typeof template === "string") {
        globalTemplates[template] = 1;
      }
    }
    for (const [filterKey, childFilterNode] of Object.entries(filterNode)) {
      if (filterKey in globalTemplates) {
        throw new Error("Global templates not yet supported for queries");
      }
      const template = field.templates.find((template2) => !(typeof template2 === "string") && template2.name === filterKey);
      const jsonPath = `${fieldName}[?(@._template=="${filterKey}")]`;
      const filterPath = pathExpression ? `${pathExpression}.${jsonPath}` : jsonPath;
      collectConditionsForChildFields(childFilterNode, template.fields, filterPath, collectCondition);
    }
  } else {
    const jsonPath = `${fieldName}${field.list ? "[*]" : ""}`;
    const filterPath = pathExpression ? `${pathExpression}.${jsonPath}` : `${jsonPath}`;
    collectConditionsForChildFields(filterNode, field.fields, filterPath, collectCondition);
  }
};
var collectConditionsForField = (fieldName, field, filterNode, pathExpression, collectCondition) => {
  if (field.type === "object") {
    collectConditionsForObjectField(fieldName, field, filterNode, pathExpression, collectCondition);
  } else {
    collectCondition({
      filterPath: pathExpression ? `${pathExpression}.${fieldName}` : fieldName,
      filterExpression: __spreadValues({
        _type: field.type
      }, filterNode)
    });
  }
};

// src/resolver/media-utils.ts
var resolveMediaCloudToRelative = (value, config = { useRelativeMedia: true }, schema) => {
  if (config && value) {
    if (config.useRelativeMedia === true) {
      return value;
    }
    if (hasTinaMediaConfig(schema) === true) {
      const assetsURL = `https://${config.assetsHost}/${config.clientId}`;
      if (typeof value === "string" && value.includes(assetsURL)) {
        const cleanMediaRoot = cleanUpSlashes(schema.config.media.tina.mediaRoot);
        const strippedURL = value.replace(assetsURL, "");
        return `${cleanMediaRoot}${strippedURL}`;
      }
      return value;
    }
    return value;
  } else {
    return value;
  }
};
var resolveMediaRelativeToCloud = (value, config = { useRelativeMedia: true }, schema) => {
  if (config && value) {
    if (config.useRelativeMedia === true) {
      return value;
    }
    if (hasTinaMediaConfig(schema) === true) {
      const cleanMediaRoot = cleanUpSlashes(schema.config.media.tina.mediaRoot);
      const strippedValue = value.replace(cleanMediaRoot, "");
      return `https://${config.assetsHost}/${config.clientId}${strippedValue}`;
    }
    return value;
  } else {
    return value;
  }
};
var cleanUpSlashes = (path5) => {
  if (path5) {
    return `/${path5.replace(/^\/+|\/+$/gm, "")}`;
  }
  return "";
};
var hasTinaMediaConfig = (schema) => {
  var _a, _b, _c, _d, _e, _f;
  if (((_c = (_b = (_a = schema.config) == null ? void 0 : _a.media) == null ? void 0 : _b.tina) == null ? void 0 : _c.publicFolder) && ((_f = (_e = (_d = schema.config) == null ? void 0 : _d.media) == null ? void 0 : _e.tina) == null ? void 0 : _f.mediaRoot)) {
    return true;
  }
  return false;
};

// src/resolver/index.ts
var import_graphql3 = __toModule(require("graphql"));
var createResolver = (args) => {
  return new Resolver(args);
};
var Resolver = class {
  constructor(init) {
    this.init = init;
    this.resolveCollection = async (args, collectionName, hasDocuments) => {
      const collection = this.tinaSchema.getCollection(collectionName);
      const extraFields = {};
      return __spreadValues(__spreadValues({
        documents: { collection, hasDocuments }
      }, collection), extraFields);
    };
    this.getDocument = async (fullPath) => {
      if (typeof fullPath !== "string") {
        throw new Error(`fullPath must be of type string for getDocument request`);
      }
      const rawData = await this.database.get(fullPath);
      const collection = this.tinaSchema.getCollection(rawData._collection);
      try {
        const template = await this.tinaSchema.getTemplateForData({
          data: rawData,
          collection
        });
        const {
          base: basename,
          ext: extension,
          name: filename
        } = import_path2.default.parse(fullPath);
        const relativePath = fullPath.replace(/\\/g, "/").replace(collection.path, "").replace(/^\/|\/$/g, "");
        const breadcrumbs = relativePath.replace(extension, "").split("/");
        const data = {
          _collection: rawData._collection,
          _template: rawData._template
        };
        try {
          await sequential(template.fields, async (field) => {
            return this.resolveFieldData(field, rawData, data);
          });
        } catch (e) {
          throw new TinaParseDocumentError({
            originalError: e,
            collection: collection.name,
            includeAuditMessage: !this.isAudit,
            file: relativePath,
            stack: e.stack
          });
        }
        const titleField = template.fields.find((x) => {
          if (x.type === "string" && (x == null ? void 0 : x.isTitle)) {
            return true;
          }
        });
        const titleFieldName = titleField == null ? void 0 : titleField.name;
        const title = data[titleFieldName || " "] || null;
        return __spreadProps(__spreadValues({
          __typename: collection.fields ? NAMER.documentTypeName(collection.namespace) : NAMER.documentTypeName(template.namespace),
          id: fullPath
        }, data), {
          _sys: {
            title,
            basename,
            filename,
            extension,
            path: fullPath,
            relativePath,
            breadcrumbs,
            collection,
            template: lastItem(template.namespace)
          },
          _values: data,
          _rawData: rawData
        });
      } catch (e) {
        if (e instanceof TinaGraphQLError) {
          throw new TinaGraphQLError(e.message, __spreadValues({
            requestedDocument: fullPath
          }, e.extensions));
        }
        throw e;
      }
    };
    this.deleteDocument = async (fullPath) => {
      if (typeof fullPath !== "string") {
        throw new Error(`fullPath must be of type string for getDocument request`);
      }
      await this.database.delete(fullPath);
    };
    this.buildObjectMutations = (fieldValue, field) => {
      if (field.fields) {
        const objectTemplate = typeof field.fields === "string" ? this.tinaSchema.getGlobalTemplate(field.fields) : field;
        if (Array.isArray(fieldValue)) {
          return fieldValue.map((item) => this.buildFieldMutations(item, objectTemplate));
        } else {
          return this.buildFieldMutations(fieldValue, objectTemplate);
        }
      }
      if (field.templates) {
        if (Array.isArray(fieldValue)) {
          return fieldValue.map((item) => {
            if (typeof item === "string") {
              throw new Error(`Expected object for template value for field ${field.name}`);
            }
            const templates = field.templates.map((templateOrTemplateName) => {
              if (typeof templateOrTemplateName === "string") {
                return this.tinaSchema.getGlobalTemplate(templateOrTemplateName);
              }
              return templateOrTemplateName;
            });
            const [templateName] = Object.entries(item)[0];
            const template = templates.find((template2) => template2.name === templateName);
            if (!template) {
              throw new Error(`Expected to find template ${templateName}`);
            }
            return __spreadProps(__spreadValues({}, this.buildFieldMutations(item[template.name], template)), {
              _template: template.name
            });
          });
        } else {
          if (typeof fieldValue === "string") {
            throw new Error(`Expected object for template value for field ${field.name}`);
          }
          const templates = field.templates.map((templateOrTemplateName) => {
            if (typeof templateOrTemplateName === "string") {
              return this.tinaSchema.getGlobalTemplate(templateOrTemplateName);
            }
            return templateOrTemplateName;
          });
          const [templateName] = Object.entries(fieldValue)[0];
          const template = templates.find((template2) => template2.name === templateName);
          if (!template) {
            throw new Error(`Expected to find template ${templateName}`);
          }
          return __spreadProps(__spreadValues({}, this.buildFieldMutations(fieldValue[template.name], template)), {
            _template: template.name
          });
        }
      }
    };
    this.createResolveDocument = async ({
      collection,
      realPath,
      args,
      isAddPendingDocument
    }) => {
      if (isAddPendingDocument === true) {
        const templateInfo = this.tinaSchema.getTemplatesForCollectable(collection);
        switch (templateInfo.type) {
          case "object":
            await this.database.addPendingDocument(realPath, {});
            break;
          case "union":
            const templateString = args.template;
            const template = templateInfo.templates.find((template2) => lastItem(template2.namespace) === templateString);
            if (!args.template) {
              throw new Error(`Must specify a template when creating content for a collection with multiple templates. Possible templates are: ${templateInfo.templates.map((t) => lastItem(t.namespace)).join(" ")}`);
            }
            if (!template) {
              throw new Error(`Expected to find template named ${templateString} in collection "${collection.name}" but none was found. Possible templates are: ${templateInfo.templates.map((t) => lastItem(t.namespace)).join(" ")}`);
            }
            await this.database.addPendingDocument(realPath, {
              _template: lastItem(template.namespace)
            });
        }
        return this.getDocument(realPath);
      }
      const params = this.buildObjectMutations(args.params[collection.name], collection);
      await this.database.put(realPath, params, collection.name);
      return this.getDocument(realPath);
    };
    this.updateResolveDocument = async ({
      collection,
      realPath,
      args,
      isAddPendingDocument,
      isCollectionSpecific
    }) => {
      const doc = await this.getDocument(realPath);
      const oldDoc = (doc == null ? void 0 : doc._rawData) || {};
      if (isAddPendingDocument === true) {
        const templateInfo = this.tinaSchema.getTemplatesForCollectable(collection);
        const params2 = this.buildParams(args);
        switch (templateInfo.type) {
          case "object":
            if (params2) {
              const values = this.buildFieldMutations(params2, templateInfo.template);
              await this.database.put(realPath, __spreadValues(__spreadValues({}, oldDoc), values), collection.name);
            }
            break;
          case "union":
            await sequential(templateInfo.templates, async (template) => {
              const templateParams = params2[lastItem(template.namespace)];
              if (templateParams) {
                if (typeof templateParams === "string") {
                  throw new Error(`Expected to find an object for template params, but got string`);
                }
                const values = __spreadProps(__spreadValues(__spreadValues({}, oldDoc), this.buildFieldMutations(templateParams, template)), {
                  _template: lastItem(template.namespace)
                });
                await this.database.put(realPath, values, collection.name);
              }
            });
        }
        return this.getDocument(realPath);
      }
      const params = this.buildObjectMutations(isCollectionSpecific ? args.params : args.params[collection.name], collection);
      await this.database.put(realPath, __spreadValues(__spreadValues({}, oldDoc), params), collection.name);
      return this.getDocument(realPath);
    };
    this.resolveDocument = async ({
      args,
      collection: collectionName,
      isMutation,
      isCreation,
      isDeletion,
      isAddPendingDocument,
      isCollectionSpecific,
      isUpdateName
    }) => {
      let collectionLookup = collectionName || void 0;
      if (!collectionLookup && isCollectionSpecific === false) {
        collectionLookup = Object.keys(args.params)[0];
      }
      const collectionNames = this.tinaSchema.getCollections().map((item) => item.name);
      assertShape(collectionLookup, (yup3) => {
        return yup3.mixed().oneOf(collectionNames);
      }, `"collection" must be one of: [${collectionNames.join(", ")}] but got ${collectionLookup}`);
      assertShape(args, (yup3) => yup3.object({ relativePath: yup3.string().required() }));
      const collection = await this.tinaSchema.getCollection(collectionLookup);
      const realPath = import_path2.default.join(collection == null ? void 0 : collection.path, args.relativePath);
      const alreadyExists = await this.database.documentExists(realPath);
      if (isMutation) {
        if (isCreation) {
          if (alreadyExists === true) {
            throw new Error(`Unable to add document, ${realPath} already exists`);
          }
          return this.createResolveDocument({
            collection,
            realPath,
            args,
            isAddPendingDocument
          });
        }
        if (!alreadyExists) {
          if (isDeletion) {
            throw new Error(`Unable to delete document, ${realPath} does not exist`);
          }
          if (isUpdateName) {
            throw new Error(`Unable to update document, ${realPath} does not exist`);
          }
        }
        if (isDeletion) {
          const doc = await this.getDocument(realPath);
          await this.deleteDocument(realPath);
          return doc;
        }
        if (isUpdateName) {
          assertShape(args, (yup3) => yup3.object({ params: yup3.object().required() }));
          assertShape(args == null ? void 0 : args.params, (yup3) => yup3.object({ relativePath: yup3.string().required() }));
          const doc = await this.getDocument(realPath);
          const newRealPath = import_path2.default.join(collection == null ? void 0 : collection.path, args.params.relativePath);
          await this.database.put(newRealPath, doc._rawData, collection.name);
          await this.deleteDocument(realPath);
          return this.getDocument(newRealPath);
        }
        if (alreadyExists === false) {
          throw new Error(`Unable to update document, ${realPath} does not exist`);
        }
        return this.updateResolveDocument({
          collection,
          realPath,
          args,
          isAddPendingDocument,
          isCollectionSpecific
        });
      } else {
        return this.getDocument(realPath);
      }
    };
    this.resolveCollectionConnections = async ({ ids }) => {
      return {
        totalCount: ids.length,
        edges: await sequential(ids, async (filepath) => {
          const document = await this.getDocument(filepath);
          return {
            node: document
          };
        })
      };
    };
    this.referenceResolver = async (filter, fieldDefinition) => {
      const referencedCollection = this.tinaSchema.getCollection(fieldDefinition.collections[0]);
      if (!referencedCollection) {
        throw new Error(`Unable to find collection for ${fieldDefinition.collections[0]} querying ${fieldDefinition.name}`);
      }
      const sortKeys = Object.keys(filter[fieldDefinition.name][referencedCollection.name]);
      const resolvedCollectionConnection = await this.resolveCollectionConnection({
        args: {
          sort: sortKeys.length === 1 ? sortKeys[0] : void 0,
          filter: __spreadValues({}, filter[fieldDefinition.name][referencedCollection.name]),
          first: -1
        },
        collection: referencedCollection,
        hydrator: (path5) => path5
      });
      const { edges } = resolvedCollectionConnection;
      const values = edges.map((edge) => edge.node);
      return { edges, values };
    };
    this.resolveCollectionConnection = async ({
      args,
      collection,
      hydrator
    }) => {
      let conditions;
      if (args.filter) {
        if (collection.fields) {
          conditions = await this.resolveFilterConditions(args.filter, collection.fields, collection.name);
        } else if (collection.templates) {
          for (const templateName of Object.keys(args.filter)) {
            const template = collection.templates.find((template2) => template2.name === templateName);
            if (template) {
              conditions = await this.resolveFilterConditions(args.filter[templateName], template.fields, `${collection.name}.${templateName}`);
            } else {
              throw new Error(`Error template not found: ${templateName} in collection ${collection.name}`);
            }
          }
        }
      }
      const queryOptions = {
        filterChain: (0, import_datalayer.makeFilterChain)({
          conditions: conditions || []
        }),
        collection: collection.name,
        sort: args.sort,
        first: args.first,
        last: args.last,
        before: args.before,
        after: args.after
      };
      const result = await this.database.query(queryOptions, hydrator ? hydrator : this.getDocument);
      const edges = result.edges;
      const pageInfo = result.pageInfo;
      return {
        totalCount: edges.length,
        edges,
        pageInfo: pageInfo || {
          hasPreviousPage: false,
          hasNextPage: false,
          startCursor: "",
          endCursor: ""
        }
      };
    };
    this.buildFieldMutations = (fieldParams, template) => {
      const accum = {};
      Object.entries(fieldParams).forEach(([fieldName, fieldValue]) => {
        if (Array.isArray(fieldValue)) {
          if (fieldValue.length === 0) {
            accum[fieldName] = [];
            return;
          }
        }
        const field = template.fields.find((field2) => field2.name === fieldName);
        if (!field) {
          throw new Error(`Expected to find field by name ${fieldName}`);
        }
        switch (field.type) {
          case "datetime":
            accum[fieldName] = resolveDateInput(fieldValue, field);
            break;
          case "string":
          case "boolean":
          case "number":
            accum[fieldName] = fieldValue;
            break;
          case "image":
            accum[fieldName] = resolveMediaCloudToRelative(fieldValue, this.config, this.tinaSchema.schema);
            break;
          case "object":
            accum[fieldName] = this.buildObjectMutations(fieldValue, field);
            break;
          case "rich-text":
            accum[fieldName] = (0, import_mdx.stringifyMDX)(fieldValue, field, (fieldValue2) => resolveMediaCloudToRelative(fieldValue2, this.config, this.tinaSchema.schema));
            break;
          case "reference":
            accum[fieldName] = fieldValue;
            break;
          default:
            throw new Error(`No mutation builder for field type ${field.type}`);
        }
      });
      return accum;
    };
    this.resolveFieldData = async (_a, rawData, accumulator) => {
      var _b = _a, { namespace } = _b, field = __objRest(_b, ["namespace"]);
      var _a2;
      if (!rawData) {
        return void 0;
      }
      assertShape(rawData, (yup3) => yup3.object());
      const value = rawData[field.name];
      switch (field.type) {
        case "datetime":
          if (value instanceof Date) {
            accumulator[field.name] = value.toISOString();
          } else {
            accumulator[field.name] = value;
          }
          break;
        case "string":
        case "boolean":
        case "number":
        case "reference":
          accumulator[field.name] = value;
          break;
        case "image":
          accumulator[field.name] = resolveMediaRelativeToCloud(value, this.config, this.tinaSchema.schema);
          break;
        case "rich-text":
          const tree = (0, import_mdx.parseMDX)(value, field, (value2) => resolveMediaRelativeToCloud(value2, this.config, this.tinaSchema.schema));
          if (((_a2 = tree == null ? void 0 : tree.children[0]) == null ? void 0 : _a2.type) === "invalid_markdown") {
            if (this.isAudit) {
              const invalidNode = tree == null ? void 0 : tree.children[0];
              throw new import_graphql3.GraphQLError(`${invalidNode == null ? void 0 : invalidNode.message}${invalidNode.position ? ` at line ${invalidNode.position.start.line}, column ${invalidNode.position.start.column}` : ""}`);
            }
          }
          accumulator[field.name] = tree;
          break;
        case "object":
          if (field.list) {
            if (!value) {
              return;
            }
            assertShape(value, (yup3) => yup3.array().of(yup3.object().required()));
            accumulator[field.name] = await sequential(value, async (item) => {
              const template = await this.tinaSchema.getTemplateForData({
                data: item,
                collection: __spreadValues({
                  namespace
                }, field)
              });
              const payload = {};
              await sequential(template.fields, async (field2) => {
                await this.resolveFieldData(field2, item, payload);
              });
              const isUnion = !!field.templates;
              return isUnion ? __spreadValues({
                _template: lastItem(template.namespace)
              }, payload) : payload;
            });
          } else {
            if (!value) {
              return;
            }
            const template = await this.tinaSchema.getTemplateForData({
              data: value,
              collection: __spreadValues({
                namespace
              }, field)
            });
            const payload = {};
            await sequential(template.fields, async (field2) => {
              await this.resolveFieldData(field2, value, payload);
            });
            const isUnion = !!field.templates;
            accumulator[field.name] = isUnion ? __spreadValues({
              _template: lastItem(template.namespace)
            }, payload) : payload;
          }
          break;
        default:
          return field;
      }
      return accumulator;
    };
    this.buildParams = (args) => {
      try {
        assertShape(args, (yup3) => yup3.object({
          collection: yup3.string().required(),
          params: yup3.object().required()
        }));
        return args.params[args.collection];
      } catch (e) {
      }
      assertShape(args, (yup3) => yup3.object({
        params: yup3.object().required()
      }));
      return args.params;
    };
    this.config = init.config;
    this.database = init.database;
    this.tinaSchema = init.tinaSchema;
    this.isAudit = init.isAudit;
  }
  async resolveFilterConditions(filter, fields, collectionName) {
    const conditions = [];
    const conditionCollector = (condition) => {
      if (!condition.filterPath) {
        throw new Error("Error parsing filter - unable to generate filterPath");
      }
      if (!condition.filterExpression) {
        throw new Error(`Error parsing filter - missing expression for ${condition.filterPath}`);
      }
      conditions.push(condition);
    };
    await resolveReferences(filter, fields, this.referenceResolver);
    for (const fieldName of Object.keys(filter)) {
      const field = fields.find((field2) => field2.name === fieldName);
      if (!field) {
        throw new Error(`${fieldName} not found in collection ${collectionName}`);
      }
      collectConditionsForField(fieldName, field, filter[fieldName], "", conditionCollector);
    }
    return conditions;
  }
};
var resolveDateInput = (value) => {
  const date = new Date(value);
  if (!(0, import_isValid.default)(date)) {
    throw "Invalid Date";
  }
  return date.toISOString();
};

// src/resolve.ts
var import_relay_operation_optimizer = __toModule(require("@graphql-tools/relay-operation-optimizer"));
var resolve = async ({
  config,
  query,
  variables,
  database,
  silenceErrors,
  verbose,
  isAudit
}) => {
  var _a;
  try {
    const verboseValue = verbose != null ? verbose : true;
    const graphQLSchemaAst = await database.getGraphQLSchema();
    const graphQLSchema = (0, import_graphql4.buildASTSchema)(graphQLSchemaAst);
    const tinaConfig = await database.getTinaSchema();
    const tinaSchema = await createSchema({
      schema: tinaConfig,
      flags: (_a = tinaConfig == null ? void 0 : tinaConfig.meta) == null ? void 0 : _a.flags
    });
    const resolver = await createResolver({
      config,
      database,
      tinaSchema,
      isAudit: isAudit || false
    });
    const res = await (0, import_graphql4.graphql)({
      schema: graphQLSchema,
      source: query,
      variableValues: variables,
      contextValue: {
        database
      },
      typeResolver: async (source, _args, info) => {
        if (source.__typename)
          return source.__typename;
        const namedType = (0, import_graphql4.getNamedType)(info.returnType).toString();
        const lookup = await database.getLookup(namedType);
        if (lookup.resolveType === "unionData") {
          return lookup.typeMap[source._template];
        } else {
          throw new Error(`Unable to find lookup key for ${namedType}`);
        }
      },
      fieldResolver: async (source = {}, _args = {}, _context, info) => {
        var _a2;
        try {
          const args = JSON.parse(JSON.stringify(_args));
          const returnType = (0, import_graphql4.getNamedType)(info.returnType).toString();
          const lookup = await database.getLookup(returnType);
          const isMutation = info.parentType.toString() === "Mutation";
          const value = source[info.fieldName];
          if (returnType === "Collection") {
            if (value) {
              return value;
            }
            if (info.fieldName === "collections") {
              const collectionNode2 = info.fieldNodes.find((x) => x.name.value === "collections");
              const hasDocuments2 = collectionNode2.selectionSet.selections.find((x) => {
                var _a3;
                return ((_a3 = x == null ? void 0 : x.name) == null ? void 0 : _a3.value) === "documents";
              });
              return tinaSchema.getCollections().map((collection) => {
                return resolver.resolveCollection(args, collection.name, Boolean(hasDocuments2));
              });
            }
            const collectionNode = info.fieldNodes.find((x) => x.name.value === "collection");
            const hasDocuments = collectionNode.selectionSet.selections.find((x) => {
              var _a3;
              return ((_a3 = x == null ? void 0 : x.name) == null ? void 0 : _a3.value) === "documents";
            });
            return resolver.resolveCollection(args, args.collection, Boolean(hasDocuments));
          }
          if (info.fieldName === "getOptimizedQuery") {
            try {
              const [optimizedQuery] = (0, import_relay_operation_optimizer.optimizeDocuments)(info.schema, [(0, import_graphql4.parse)(args.queryString)], {
                assumeValid: true,
                includeFragments: false,
                noLocation: true
              });
              return (0, import_graphql4.print)(optimizedQuery);
            } catch (e) {
              throw new Error(`Invalid query provided, Error message: ${e.message}`);
            }
          }
          if (!lookup) {
            return value;
          }
          const isCreation = lookup[info.fieldName] === "create";
          switch (lookup.resolveType) {
            case "nodeDocument":
              assertShape(args, (yup3) => yup3.object({ id: yup3.string().required() }));
              return resolver.getDocument(args.id);
            case "multiCollectionDocument":
              if (typeof value === "string") {
                return resolver.getDocument(value);
              }
              if (args && args.collection && info.fieldName === "addPendingDocument") {
                return resolver.resolveDocument({
                  args: __spreadProps(__spreadValues({}, args), { params: {} }),
                  collection: args.collection,
                  isMutation,
                  isCreation: true,
                  isAddPendingDocument: true
                });
              }
              if ([
                NAMER.documentQueryName(),
                "createDocument",
                "updateDocument",
                "deleteDocument"
              ].includes(info.fieldName)) {
                const result2 = await resolver.resolveDocument({
                  args,
                  collection: args.collection,
                  isMutation,
                  isCreation,
                  isDeletion: info.fieldName === "deleteDocument",
                  isUpdateName: Boolean((_a2 = args == null ? void 0 : args.params) == null ? void 0 : _a2.relativePath),
                  isAddPendingDocument: false,
                  isCollectionSpecific: false
                });
                return result2;
              }
              return value;
            case "multiCollectionDocumentList":
              if (Array.isArray(value)) {
                return {
                  totalCount: value.length,
                  edges: value.map((document) => {
                    return { node: document };
                  })
                };
              } else if (info.fieldName === "documents" && (value == null ? void 0 : value.collection) && (value == null ? void 0 : value.hasDocuments)) {
                return resolver.resolveCollectionConnection({
                  args,
                  collection: value.collection
                });
              } else {
                throw new Error(`Expected an array for result of ${info.fieldName} at ${info.path}`);
              }
            case "collectionDocument":
              if (value) {
                return value;
              }
              const result = value || await resolver.resolveDocument({
                args,
                collection: lookup.collection,
                isMutation,
                isCreation,
                isAddPendingDocument: false,
                isCollectionSpecific: true
              });
              return result;
            case "collectionDocumentList":
              return resolver.resolveCollectionConnection({
                args,
                collection: tinaSchema.getCollection(lookup.collection)
              });
            case "unionData":
              if (!value) {
                if (args.relativePath) {
                  const result2 = await resolver.resolveDocument({
                    args,
                    collection: lookup.collection,
                    isMutation,
                    isCreation,
                    isAddPendingDocument: false,
                    isCollectionSpecific: true
                  });
                  return result2;
                }
              }
              return value;
            default:
              console.error(lookup);
              throw new Error(`Unexpected resolve type`);
          }
        } catch (e) {
          handleFetchErrorError(e, verboseValue);
        }
      }
    });
    if (res.errors) {
      if (!silenceErrors) {
        res.errors.map((e) => {
          console.error(e.toString());
          if (verboseValue) {
            console.error("More error context below");
            console.error(e.message);
            console.error(e);
          }
        });
      }
    }
    return res;
  } catch (e) {
    if (!silenceErrors) {
      console.error(e);
    }
    if (e instanceof import_graphql4.GraphQLError) {
      return {
        errors: [e]
      };
    } else {
      throw e;
    }
  }
};

// src/database/index.ts
var import_path3 = __toModule(require("path"));
var import_graphql5 = __toModule(require("graphql"));

// src/database/util.ts
var import_toml = __toModule(require("@iarna/toml"));
var import_js_yaml = __toModule(require("js-yaml"));
var import_gray_matter = __toModule(require("gray-matter"));
var matterEngines = {
  toml: {
    parse: (val) => import_toml.default.parse(val),
    stringify: (val) => import_toml.default.stringify(val)
  }
};
var stringifyFile = (content, format, keepTemplateKey, markdownParseConfig) => {
  const _a = content, {
    _relativePath,
    _keepTemplateKey,
    _id,
    _template,
    _collection,
    $_body
  } = _a, rest = __objRest(_a, [
    "_relativePath",
    "_keepTemplateKey",
    "_id",
    "_template",
    "_collection",
    "$_body"
  ]);
  const extra = {};
  if (keepTemplateKey) {
    extra["_template"] = _template;
  }
  const strippedContent = __spreadValues(__spreadValues({}, rest), extra);
  switch (format) {
    case ".markdown":
    case ".mdx":
    case ".md":
      const ok = import_gray_matter.default.stringify(typeof $_body === "undefined" ? "" : `
${$_body}`, strippedContent, {
        language: (markdownParseConfig == null ? void 0 : markdownParseConfig.frontmatterFormat) || "yaml",
        engines: matterEngines,
        delimiters: (markdownParseConfig == null ? void 0 : markdownParseConfig.frontmatterDelimiters) || "---"
      });
      return ok;
    case ".json":
      return JSON.stringify(strippedContent, null, 2);
    case ".yaml":
      return import_js_yaml.default.safeDump(strippedContent);
    case ".toml":
      return import_toml.default.stringify(strippedContent);
    default:
      throw new Error(`Must specify a valid format, got ${format}`);
  }
};
var parseFile = (content, format, yupSchema, markdownParseConfig) => {
  switch (format) {
    case ".markdown":
    case ".mdx":
    case ".md":
      const contentJSON = (0, import_gray_matter.default)(content || "", {
        language: (markdownParseConfig == null ? void 0 : markdownParseConfig.frontmatterFormat) || "yaml",
        delimiters: (markdownParseConfig == null ? void 0 : markdownParseConfig.frontmatterDelimiters) || "---",
        engines: matterEngines
      });
      const markdownData = __spreadProps(__spreadValues({}, contentJSON.data), {
        $_body: contentJSON.content
      });
      assertShape(markdownData, yupSchema);
      return markdownData;
    case ".json":
      if (!content) {
        return {};
      }
      return JSON.parse(content);
    case ".toml":
      if (!content) {
        return {};
      }
      return import_toml.default.parse(content);
    case ".yaml":
      if (!content) {
        return {};
      }
      return import_js_yaml.default.safeLoad(content);
    default:
      throw new Error(`Must specify a valid format, got ${format}`);
  }
};
var normalizePath = (filepath) => filepath.replace(/\\/g, "/");

// src/database/index.ts
var import_datalayer2 = __toModule(require("@tinacms/datalayer"));
var createDatabase = async (config) => {
  return new Database(__spreadProps(__spreadValues({}, config), {
    bridge: config.bridge,
    store: config.store
  }));
};
var SYSTEM_FILES = ["_schema", "_graphql", "_lookup"];
var defaultStatusCallback = () => Promise.resolve();
var Database = class {
  constructor(config) {
    this.config = config;
    this.collectionForPath = async (filepath) => {
      const tinaSchema = await this.getSchema();
      const collection = tinaSchema.getCollectionByFullPath(filepath);
      return collection;
    };
    this.getGeneratedFolder = () => import_path3.default.join(this.tinaDirectory, "__generated__");
    this.get = async (filepath) => {
      if (SYSTEM_FILES.includes(filepath)) {
        throw new Error(`Unexpected get for config file ${filepath}`);
      } else {
        const tinaSchema = await this.getSchema();
        const extension = import_path3.default.extname(filepath);
        const contentObject = await this.store.get(normalizePath(filepath));
        if (!contentObject) {
          throw new import_graphql5.GraphQLError(`Unable to find record ${filepath}`);
        }
        const templateName = hasOwnProperty(contentObject, "_template") && typeof contentObject._template === "string" ? contentObject._template : void 0;
        const { collection, template } = tinaSchema.getCollectionAndTemplateByFullPath(filepath, templateName);
        const field = template.fields.find((field2) => {
          if (field2.type === "string" || field2.type === "rich-text") {
            if (field2.isBody) {
              return true;
            }
          }
          return false;
        });
        let data = contentObject;
        if ((extension === ".md" || extension === ".mdx") && field) {
          if (hasOwnProperty(contentObject, "$_body")) {
            const _a = contentObject, { $_body } = _a, rest = __objRest(_a, ["$_body"]);
            data = rest;
            data[field.name] = $_body;
          }
        }
        return __spreadProps(__spreadValues({}, data), {
          _collection: collection.name,
          _keepTemplateKey: !!collection.templates,
          _template: lastItem(template.namespace),
          _relativePath: filepath.replace(collection.path, "").replace(/^\/|\/$/g, ""),
          _id: filepath
        });
      }
    };
    this.addPendingDocument = async (filepath, data) => {
      const { stringifiedFile, payload, keepTemplateKey } = await this.stringifyFile(filepath, data);
      const collection = await this.collectionForPath(filepath);
      let collectionIndexDefinitions;
      if (collection) {
        const indexDefinitions = await this.getIndexDefinitions();
        collectionIndexDefinitions = indexDefinitions == null ? void 0 : indexDefinitions[collection.name];
      }
      if (this.store.supportsSeeding()) {
        await this.bridge.put(normalizePath(filepath), stringifiedFile);
      }
      await this.store.put(normalizePath(filepath), payload, {
        keepTemplateKey,
        collection: collection == null ? void 0 : collection.name,
        indexDefinitions: collectionIndexDefinitions
      });
    };
    this.put = async (filepath, data, collection) => {
      try {
        if (SYSTEM_FILES.includes(filepath)) {
          throw new Error(`Unexpected put for config file ${filepath}`);
        } else {
          let collectionIndexDefinitions;
          if (collection) {
            const indexDefinitions = await this.getIndexDefinitions();
            collectionIndexDefinitions = indexDefinitions == null ? void 0 : indexDefinitions[collection];
          }
          const { stringifiedFile, payload, keepTemplateKey } = await this.stringifyFile(filepath, data);
          if (this.store.supportsSeeding()) {
            await this.bridge.put(normalizePath(filepath), stringifiedFile);
          }
          await this.store.put(normalizePath(filepath), payload, {
            keepTemplateKey,
            collection,
            indexDefinitions: collectionIndexDefinitions
          });
        }
        return true;
      } catch (error) {
        throw new TinaFetchError(`Error in PUT for ${filepath}`, {
          originalError: error,
          file: filepath,
          collection,
          stack: error.stack
        });
      }
    };
    this.stringifyFile = async (filepath, data) => {
      if (SYSTEM_FILES.includes(filepath)) {
        throw new Error(`Unexpected put for config file ${filepath}`);
      } else {
        const tinaSchema = await this.getSchema();
        const collection = tinaSchema.getCollectionByFullPath(filepath);
        const templateInfo = await tinaSchema.getTemplatesForCollectable(collection);
        let template;
        if (templateInfo.type === "object") {
          template = templateInfo.template;
        }
        if (templateInfo.type === "union") {
          if (hasOwnProperty(data, "_template")) {
            template = templateInfo.templates.find((t) => lastItem(t.namespace) === data._template);
          } else {
            throw new Error(`Expected _template to be provided for document in an ambiguous collection`);
          }
        }
        if (!template) {
          throw new Error(`Unable to determine template`);
        }
        const field = template.fields.find((field2) => {
          if (field2.type === "string" || field2.type === "rich-text") {
            if (field2.isBody) {
              return true;
            }
          }
          return false;
        });
        let payload = {};
        if (["md", "mdx"].includes(collection.format) && field) {
          Object.entries(data).forEach(([key, value]) => {
            if (key !== field.name) {
              payload[key] = value;
            }
          });
          payload["$_body"] = data[field.name];
        } else {
          payload = data;
        }
        const extension = import_path3.default.extname(filepath);
        const stringifiedFile = stringifyFile(payload, extension, templateInfo.type === "union", {
          frontmatterFormat: collection == null ? void 0 : collection.frontmatterFormat,
          frontmatterDelimiters: collection == null ? void 0 : collection.frontmatterDelimiters
        });
        return {
          stringifiedFile,
          payload,
          keepTemplateKey: templateInfo.type === "union"
        };
      }
    };
    this.flush = async (filepath) => {
      const data = await this.get(filepath);
      const { stringifiedFile } = await this.stringifyFile(filepath, data);
      return stringifiedFile;
    };
    this.getLookup = async (returnType) => {
      const lookupPath = import_path3.default.join(this.getGeneratedFolder(), `_lookup.json`);
      if (!this._lookup) {
        const _lookup = await this.store.get(normalizePath(lookupPath));
        this._lookup = _lookup;
      }
      return this._lookup[returnType];
    };
    this.getGraphQLSchema = async () => {
      const graphqlPath = import_path3.default.join(this.getGeneratedFolder(), `_graphql.json`);
      return this.store.get(normalizePath(graphqlPath));
    };
    this.getGraphQLSchemaFromBridge = async () => {
      const graphqlPath = import_path3.default.join(this.getGeneratedFolder(), `_graphql.json`);
      const _graphql = await this.bridge.get(normalizePath(graphqlPath));
      return JSON.parse(_graphql);
    };
    this.getTinaSchema = async () => {
      const schemaPath = import_path3.default.join(this.getGeneratedFolder(), `_schema.json`);
      return this.store.get(normalizePath(schemaPath));
    };
    this.getSchema = async () => {
      if (this.tinaSchema) {
        return this.tinaSchema;
      }
      const schema = await this.getTinaSchema();
      this.tinaSchema = await createSchema({ schema });
      return this.tinaSchema;
    };
    this.getIndexDefinitions = async () => {
      if (!this.collectionIndexDefinitions) {
        await new Promise(async (resolve2, reject) => {
          try {
            const schema = await this.getSchema();
            const collections = schema.getCollections();
            for (const collection of collections) {
              const indexDefinitions = {
                [import_datalayer2.DEFAULT_COLLECTION_SORT_KEY]: { fields: [] }
              };
              if (collection.fields) {
                for (const field of collection.fields) {
                  if (field.indexed !== void 0 && field.indexed === false || field.type === "object") {
                    continue;
                  }
                  indexDefinitions[field.name] = {
                    fields: [
                      {
                        name: field.name,
                        type: field.type,
                        pad: field.type === "number" ? { fillString: "0", maxLength: import_datalayer2.DEFAULT_NUMERIC_LPAD } : void 0
                      }
                    ]
                  };
                }
              }
              if (collection.indexes) {
                for (const index of collection.indexes) {
                  indexDefinitions[index.name] = {
                    fields: index.fields.map((indexField) => {
                      var _a;
                      return {
                        name: indexField.name,
                        type: (_a = collection.fields.find((field) => indexField.name === field.name)) == null ? void 0 : _a.type
                      };
                    })
                  };
                }
              }
              this.collectionIndexDefinitions = this.collectionIndexDefinitions || {};
              this.collectionIndexDefinitions[collection.name] = indexDefinitions;
            }
            resolve2();
          } catch (err) {
            reject(err);
          }
        });
      }
      return this.collectionIndexDefinitions;
    };
    this.documentExists = async (fullpath) => {
      try {
        await this.get(fullpath);
      } catch (e) {
        return false;
      }
      return true;
    };
    this.query = async (queryOptions, hydrator) => {
      const { first, after, last, before, sort, collection, filterChain } = queryOptions;
      const storeQueryOptions = {
        sort,
        collection,
        filterChain
      };
      if (first) {
        storeQueryOptions.limit = first;
      } else if (last) {
        storeQueryOptions.limit = last;
      } else {
        storeQueryOptions.limit = 50;
      }
      if (after) {
        storeQueryOptions.gt = (0, import_datalayer2.atob)(after);
      } else if (before) {
        storeQueryOptions.lt = (0, import_datalayer2.atob)(before);
      }
      if (last) {
        storeQueryOptions.reverse = true;
      }
      const indexDefinitions = await this.getIndexDefinitions();
      storeQueryOptions.indexDefinitions = indexDefinitions == null ? void 0 : indexDefinitions[queryOptions.collection];
      if (!storeQueryOptions.indexDefinitions) {
        throw new Error(`No indexDefinitions for collection ${queryOptions.collection}`);
      }
      const {
        edges,
        pageInfo: { hasPreviousPage, hasNextPage, startCursor, endCursor }
      } = await this.store.query(storeQueryOptions);
      return {
        edges: await sequential(edges, async (edge) => {
          try {
            const node = await hydrator(edge.path);
            return {
              node,
              cursor: (0, import_datalayer2.btoa)(edge.cursor)
            };
          } catch (error) {
            if (error instanceof Error && (!edge.path.includes(".tina/__generated__/_graphql.json") || !edge.path.includes("tina/__generated__/_graphql.json"))) {
              throw new TinaQueryError({
                originalError: error,
                file: edge.path,
                collection,
                stack: error.stack
              });
            } else {
              throw error;
            }
          }
        }),
        pageInfo: {
          hasPreviousPage,
          hasNextPage,
          startCursor: (0, import_datalayer2.btoa)(startCursor),
          endCursor: (0, import_datalayer2.btoa)(endCursor)
        }
      };
    };
    this.putConfigFiles = async ({
      graphQLSchema,
      tinaSchema
    }) => {
      if (this.bridge.supportsBuilding()) {
        await this.bridge.putConfig(normalizePath(import_path3.default.join(this.getGeneratedFolder(), `_graphql.json`)), JSON.stringify(graphQLSchema));
        await this.bridge.putConfig(normalizePath(import_path3.default.join(this.getGeneratedFolder(), `_schema.json`)), JSON.stringify(tinaSchema.schema));
      }
    };
    this.indexContent = async ({
      graphQLSchema,
      tinaSchema,
      lookup: lookupFromLockFile
    }) => {
      await this.indexStatusCallbackWrapper(async () => {
        const lookup = lookupFromLockFile || JSON.parse(await this.bridge.get(normalizePath(import_path3.default.join(this.getGeneratedFolder(), "_lookup.json"))));
        if (this.store.supportsSeeding()) {
          await this.store.clear();
          await this.store.seed(normalizePath(import_path3.default.join(this.getGeneratedFolder(), "_graphql.json")), graphQLSchema);
          await this.store.seed(normalizePath(import_path3.default.join(this.getGeneratedFolder(), "_schema.json")), tinaSchema.schema);
          await this.store.seed(normalizePath(import_path3.default.join(this.getGeneratedFolder(), "_lookup.json")), lookup);
          await this._indexAllContent();
        } else {
          if (this.store.supportsIndexing()) {
            throw new Error(`Schema must be indexed with provided Store`);
          }
        }
      });
    };
    this.deleteContentByPaths = async (documentPaths) => {
      await this.indexStatusCallbackWrapper(async () => {
        const { pathsByCollection, nonCollectionPaths, collections } = await this.partitionPathsByCollection(documentPaths);
        for (const collection of Object.keys(pathsByCollection)) {
          await _deleteIndexContent(this, pathsByCollection[collection], collections[collection]);
        }
        await _deleteIndexContent(this, nonCollectionPaths, null);
      });
    };
    this.indexContentByPaths = async (documentPaths) => {
      await this.indexStatusCallbackWrapper(async () => {
        const { pathsByCollection, nonCollectionPaths, collections } = await this.partitionPathsByCollection(documentPaths);
        for (const collection of Object.keys(pathsByCollection)) {
          await _indexContent(this, pathsByCollection[collection], collections[collection]);
        }
        await _indexContent(this, nonCollectionPaths);
      });
    };
    this.delete = async (filepath) => {
      const collection = await this.collectionForPath(filepath);
      let collectionIndexDefinitions;
      if (collection) {
        const indexDefinitions = await this.getIndexDefinitions();
        collectionIndexDefinitions = indexDefinitions == null ? void 0 : indexDefinitions[collection.name];
      }
      await this.store.delete(normalizePath(filepath), {
        collection: collection.name,
        indexDefinitions: collectionIndexDefinitions
      });
      await this.bridge.delete(normalizePath(filepath));
    };
    this._indexAllContent = async () => {
      const tinaSchema = await this.getSchema();
      await sequential(tinaSchema.getCollections(), async (collection) => {
        const documentPaths = await this.bridge.glob(normalizePath(collection.path), collection.format || "md");
        await _indexContent(this, documentPaths, collection);
      });
    };
    this.addToLookupMap = async (lookup) => {
      const lookupPath = import_path3.default.join(this.getGeneratedFolder(), `_lookup.json`);
      let lookupMap;
      try {
        lookupMap = JSON.parse(await this.bridge.get(normalizePath(lookupPath)));
      } catch (e) {
        lookupMap = {};
      }
      const updatedLookup = __spreadProps(__spreadValues({}, lookupMap), {
        [lookup.type]: lookup
      });
      await this.bridge.putConfig(normalizePath(lookupPath), JSON.stringify(updatedLookup));
    };
    this.tinaDirectory = config.tinaDirectory || ".tina";
    this.bridge = config.bridge;
    this.store = config.store;
    this.indexStatusCallback = config.indexStatusCallback || defaultStatusCallback;
  }
  async partitionPathsByCollection(documentPaths) {
    const pathsByCollection = {};
    const nonCollectionPaths = [];
    const collections = {};
    for (const documentPath of documentPaths) {
      const collection = await this.collectionForPath(documentPath);
      if (collection) {
        if (!pathsByCollection[collection.name]) {
          pathsByCollection[collection.name] = [];
        }
        collections[collection.name] = collection;
        pathsByCollection[collection.name].push(documentPath);
      } else {
        nonCollectionPaths.push(documentPath);
      }
    }
    return { pathsByCollection, nonCollectionPaths, collections };
  }
  clearCache() {
    this.tinaSchema = null;
    this._lookup = null;
  }
  async indexStatusCallbackWrapper(fn) {
    await this.indexStatusCallback({ status: "inprogress" });
    try {
      await fn();
      await this.indexStatusCallback({ status: "complete" });
    } catch (error) {
      await this.indexStatusCallback({ status: "failed", error });
      throw error;
    }
  }
};
function hasOwnProperty(obj, prop) {
  return obj.hasOwnProperty(prop);
}
var _indexContent = async (database, documentPaths, collection) => {
  let seedOptions = void 0;
  if (collection) {
    const indexDefinitions = await database.getIndexDefinitions();
    const collectionIndexDefinitions = indexDefinitions == null ? void 0 : indexDefinitions[collection.name];
    if (!collectionIndexDefinitions) {
      throw new Error(`No indexDefinitions for collection ${collection.name}`);
    }
    const numIndexes = Object.keys(collectionIndexDefinitions).length;
    if (numIndexes > 20) {
      throw new Error(`A maximum of 20 indexes are allowed per field. Currently collection ${collection.name} has ${numIndexes} indexes. Add 'indexed: false' to exclude a field from indexing.`);
    }
    seedOptions = {
      collection: collection.name,
      indexDefinitions: collectionIndexDefinitions
    };
  }
  await sequential(documentPaths, async (filepath) => {
    try {
      const dataString = await database.bridge.get(normalizePath(filepath));
      const data = parseFile(dataString, import_path3.default.extname(filepath), (yup3) => yup3.object({}), {
        frontmatterDelimiters: collection == null ? void 0 : collection.frontmatterDelimiters,
        frontmatterFormat: collection == null ? void 0 : collection.frontmatterFormat
      });
      if (database.store.supportsSeeding()) {
        await database.store.seed(normalizePath(filepath), data, seedOptions);
      }
    } catch (error) {
      throw new TinaFetchError(`Unable to seed ${filepath}`, {
        originalError: error,
        file: filepath,
        collection: collection.name,
        stack: error.stack
      });
    }
  });
};
var _deleteIndexContent = async (database, documentPaths, collection) => {
  let deleteOptions = void 0;
  if (collection) {
    const indexDefinitions = await database.getIndexDefinitions();
    const collectionIndexDefinitions = indexDefinitions == null ? void 0 : indexDefinitions[collection.name];
    if (!collectionIndexDefinitions) {
      throw new Error(`No indexDefinitions for collection ${collection.name}`);
    }
    deleteOptions = {
      collection: collection.name,
      indexDefinitions: collectionIndexDefinitions
    };
  }
  await sequential(documentPaths, async (filepath) => {
    database.store.delete(filepath, deleteOptions);
  });
};

// src/index.ts
var buildSchema = async (rootPath, database, flags) => {
  const tempConfig = import_path4.default.join(rootPath, ".tina", "__generated__", "config");
  const config = await import_fs_extra2.default.readFileSync(import_path4.default.join(tempConfig, "schema.json")).toString();
  await import_fs_extra2.default.remove(tempConfig);
  const { graphQLSchema, tinaSchema } = await buildDotTinaFiles({
    database,
    config: JSON.parse(config),
    flags
  });
  return { graphQLSchema, tinaSchema };
};
var getASTSchema = async (database) => {
  const gqlAst = await database.getGraphQLSchemaFromBridge();
  return (0, import_graphql6.buildASTSchema)(gqlAst);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  TinaFetchError,
  TinaGraphQLError,
  TinaParseDocumentError,
  TinaQueryError,
  assertShape,
  buildDotTinaFiles,
  buildSchema,
  createDatabase,
  createSchema,
  getASTSchema,
  handleFetchErrorError,
  parseFile,
  resolve,
  sequential,
  stringifyFile
});
