/**
Copyright 2021 Forestry.io Holdings, Inc.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
import { Form, Field, TinaCMS } from '@tinacms/toolkit';
import type { DocumentBlueprint, FieldBlueprint, FormifiedDocumentNode, OnChangeEvent, FormNode, State, ChangeSet, BlueprintPath } from './types';
import { formifyCallback, onSubmitArgs } from '../use-graphql-forms';
interface RecursiveFormifiedDocumentNode<T extends object> extends Array<RecursiveFormifiedDocumentNode<T> | T> {
}
/**
 * Gets the value from an object for a given blueprint for _all_ possible values.
 * eg. If the blueprint is `getCollection.documents.edges.[].node` and the value is:
 * ```
 * {
 *   getCollection: {
 *      documents: {
 *        edges: [{
 *          node: valueA
 *        },
 *        {
 *          node: valueB
 *        }]
 *      }
 *   }
 * }
 * ```
 * The response would be an array containing `valueA` and `valueB`
 *
 */
export declare const getValueForBlueprint: <T extends object>(state: object, path: string) => T | RecursiveFormifiedDocumentNode<T>;
/**
 * Returns the name of the field. In the example query, `title` and `t` would both be blueprint fields
 *
 * ```graphql
 * {
 *   getPostDocument(relativePath: $relativePath) {
 *     data {
 *       title,
 *       t: title # here `t` is an alias for title
 *     }
 *   }
 * }
 * ```
 */
export declare const getFieldNameOrAlias: (fieldBlueprint: FieldBlueprint) => string;
export declare const buildForm: (doc: FormifiedDocumentNode, cms: TinaCMS, formify: formifyCallback, showInSidebar?: boolean, onSubmit?: (args: onSubmitArgs) => void) => Form;
export declare const formNodeId: (formNode: FormNode) => string;
export declare const formNodePath: (formNode: FormNode) => string;
export declare const formNodeNotIn: (formNode: FormNode, formNodes: FormNode[]) => boolean;
export declare const sequential: <A, B>(items: A[], callback: (args: A, idx: number) => Promise<B>) => Promise<B[]>;
export declare const getFormNodesForField: (fieldBlueprint: FieldBlueprint, formNode: FormNode, event: OnChangeEvent, state: State) => {
    pathToChange: string;
    formNodes: FormNode[];
    eventLocation: any[];
    existing: any;
};
export declare const getBlueprintAliasPath: (blueprint: DocumentBlueprint) => string;
export declare const getFieldAliasForBlueprint: (path: BlueprintPath[]) => string;
/**
 *
 * Determines the appropriate fields which should recieve an update from a form change
 *
 * In cases where there's polymorphic blocks, it's possible that an update would affect
 * multiple locations that it shouldn't.
 *
 * An OnChange event name can look like: `blocks.2.title`, but if there are 2 block elements
 * with a field of the same name, an event name it wouldn't be enough information for us.
 *
 * To get around this, the event sends the current `typename` along with it, and we use that
 * to determine where in our blueprint the value should be updated.
 *
 */
export declare const getBlueprintFieldsForEvent: (blueprint: DocumentBlueprint, event: OnChangeEvent) => FieldBlueprint[];
export declare const filterFieldBlueprintsByParentTypename: (fbp: FieldBlueprint, typename: any) => boolean;
/**
 *
 * Returns the human-readable path to a blueprint or blueprint field.
 * Optionally, appends a disambiguator to the string where necessary.
 *
 * eg. if a blocks field is polymporphic, specifying `true` for the disambiguator
 *
 * ```
 * getPageDocument.data.blocks[].PageBlocksCta.title
 * ```
 */
export declare const getBlueprintNamePath: (blueprint: Pick<DocumentBlueprint, 'path'>, disambiguator?: boolean) => string;
export declare const stripIndices: (string: any) => any[];
export declare const replaceRealNum: (string: any) => any;
export declare const getMatchName: ({ field, prefix, blueprint }: {
    field: any;
    prefix: any;
    blueprint: any;
}) => {
    matchName: string;
    fieldName: any;
};
export declare const getFormNodesFromEvent: (state: State, event: OnChangeEvent) => FormNode[];
export declare const printState: (state: State) => string;
export declare const printEvent: (event: OnChangeEvent) => {
    type: "forms:fields:onChange" | "forms:reset";
    value: unknown;
    previousValue: unknown;
    mutationType: import("./types").ChangeMutation | import("./types").ReferenceChangeMutation | import("./types").InsertMutation | import("./types").MoveMutation | import("./types").RemoveMutation | import("./types").ResetMutation | import("./types").GlobalMutation;
    formId: string;
    field: {
        data: {
            tinaField: {
                name: string;
                type: "string" | "object" | "reference";
                list?: boolean;
                parentTypename: string;
            };
        };
        name: string;
    };
};
export declare const getFormNodeBlueprint: (formNode: FormNode, state: State) => DocumentBlueprint;
export declare const getMoveMapping: (existing: any, from: any, to: any) => {
    [key: number]: number;
};
export declare const matchLocation: (eventLocation: number[], formNode: FormNode) => boolean;
export declare const bumpLocation: (location: number[]) => number[];
export declare const maybeLowerLocation: (location: number[], at: number) => number[];
export declare const matchesAt: (location: number[], at: number) => boolean;
export declare const swapLocation: (location: number[], mapping: {
    [key: number]: number;
}) => number[];
/**
 *
 * Gets the sub-fields for an object field, if it's a polymorphic
 * object then we also need to get the __typename, though
 * we should probably supply that regardless. The current downside
 * of this is that it needs to come from the server because we
 * have no way of knowing what it would be from the client-side
 */
export declare const getSubFields: (changeSet: ChangeSet) => {
    fields: Field[];
    __typename: string;
};
export {};
